XFIX←{   
  ⍺←1
  DEBUG←1
  0/⍨~DEBUG:: ⎕SIGNAL/⎕DMX.(EM EN)
⍝ If ⍵ is a filename (char vector), process the file contents
  1≥|≡⍵: ⍺ ∇ ⊆⊃⎕NGET ⍵ 1
  ⎕IO← 0
  
⍝ ⍵ is (now or initially) a vector of lines (char vectors)

⍝ CONSTANTS
  SQ DQ LP RP←'''"()' 
  CR NL←⎕UCS 13 10 
  DQ2←DQ,DQ
  QSEP←SQ,' ',SQ       ⍝ QSEP: Separates Two Quote Strings 
  OPTS←('UCP' 1)('Mode' 'M')('EOL' 'LF')('IC' 1)

⍝ Utility Fns 
⍝ Fld: Select a numbered field of ⎕R namespace
  Fld← { o b l←⍺.(Offsets Block Lengths) ⋄ 0≠0(≢o)⍸⍵: '' ⋄ ¯1≠oo←⍵⌷o: ll↑oo↓b ⊣ ll←⍵⌷l ⋄ '' }
  AddSQs←     { SQ,SQ,⍨∊(⊂QSEP)@(NL∘=)⊢⍵  }           ⍝ Add single quotes to each quoted string...
  DQ2SQ←      { {⍵/⍨DQ2(~⍷)⍵}(⍵/⍨1+SQ=⍵) }            ⍝ Internal double quotes to single quotes 
  CondParens← { ⍺: Parens ⍵ ⋄ ⍵ }
  CondQuotes← { ⍺: Quotes ⍵ ⋄ ⍵ }
  CondEval←   { 0:: '' ⋄ ⍺: ⍕ ⍎⍵ ⋄ ⍵ }
  Parens←     (LP∘,,∘RP)
  Quotes←     (SQ∘,,∘SQ){⍵/⍨1+SQ=⍵}
  DTB←        {⍵↓⍨-+/∧\⌽⍵=' '}
  HandleNL←   { 2≤⍴⍴⍵: ∊∇¨(⎕FMT ⍵),NL  ⋄ '\\⋄' ⎕R '\n' ⊣⍵ }
  Strip1LR← 1↓¯1↓⊢
⍝ Strip trailing blanks from lines of multiline strings...
  StripTB← { NL(~∊)⍵: ⍵ ⋄ ' *\n'  ⎕R  '\n'  ⍠OPTS ⊢⍵ } 

⍝ Regexp Alignment Fns 
⍝ AlignLeft: No Leading Blanks...
  AlignLeft←  '\n *' ⎕R '\n' ⍠OPTS
⍝ AlignMarg: In a multiline string, 
⍝            align subseq lines with the margin in the first line, ignoring an initial bare newline.
  AlignMarg← {
    isFirst margin skipNL1← 1 0 0
    ⍝ Initial bare newline is ignored...
    ⍝ Set left margin from first "full" line and align following with that.
      '\A(?=\n)' '\n( *)' ⎕R {
          0=⍵.PatternNum: '' ⊣ skipNL1⊢←1                    ⍝ We skip newline at <isFirst>
          nsp← ≢⍵ Fld 1
          isFirst: skipNL1↓NL ⊣ isFirst margin⊢← 0 nsp       ⍝ Set margin 
          NL,' '⍴⍨0⌈margin-⍨nsp                              ⍝ Align with margin         
      }⍠OPTS ⊢ ⍵ 
  }

⍝ Dictionary...
  ∆DICT←{ 
      K V←⍵
      Get←{ 
          k1←1 ⎕C⍣('⎕'=⍬⍴⍵)⊢⍵ 
          p←K⍳⊂k1  ⋄ p=≢K: ⍵ ⋄ p⊃V
      }
      Set←{ k1 v1←⍵
          p←K⍳⊂k1
          p=≢K: v1⊣K,←⊂k1 ⊣ V,←⊂v1
          ⊢(p⊃V)←v1 
      }
      Del←{
          p←K⍳⊂⍵
          p=≢K: ⍵
          q←p≠⍳≢K ⋄ K⊢←q/K ⋄ V⊢←q/V
          ⍵
      }
      ⎕NS  'K' 'V' 'Get' 'Set' 'Del'
  }
  
  sqP←       '(''[^'']*'')+'
  dqP←       '("[^"]*")+' 
  comP←      '⍝[^\n]*$'
  numP←      '¯?[\d\.][\d\.EeJj¯]*'  
  nlP←       '\n'
  miscP←     '[^''"⍝\n]+'
  sinkP←     '((?:^|[[{(⋄:\n])\h*)←' 
  tempP←     '⎕T\b'
  _w←        '[\w∆⍙]'
  _w0←       '[⎕\w∆⍙](?<![\d¯])'
  _wordP←     _w0,_w,'*(?:\.',_w0,_w,'*)*'
  wordP←      Parens _wordP
  qLP←        '(?|(?<='')|',wordP,')\h*→'
  qRP←        '`\h*(?|(?='')|',wordP ,')'
  qRErrP←     '`'    
  defP←       '^\h*:DEF([ELQ]*)\h+(\S+)\h?(.*)$'
  undefP←     '^\h*:UNDEF\h+(\S+)\h*(.*)$'

  ProcStrings← sqP dqP comP nlP miscP ⎕R { 
        sqI dqI←   0 1  
        CASE← ⍵.PatternNum∘∊
        f0← ⍵ Fld 0
        CASE sqI:  (NL∊f0)∘CondParens AddSQs AlignLeft StripTB       Strip1LR f0
        CASE dqI:  (NL∊f0)∘CondParens AddSQs AlignMarg StripTB DQ2SQ Strip1LR f0
      ⍝ ELSE...
        f0 
  } ⍠OPTS  

  ProcMacros←sqP comP numP defP undefP wordP  ⎕R {
      sqI comI numI defI undefI wordI← 0 1 2 3 4 5
      CASE← ⍵.PatternNum∘∊
      f0 f1 f2 f3← ⍵ Fld¨ 0 1 2 3
      CASE sqI comI numI: f0 
      CASE defI:   {
          ¯1=⎕NC f2~'⎕': 11 ⎕SIGNAL⍨ ':DEF ERROR: Invalid object name: "',f2,'"',CR,'[Line] ',f0
          isNotNull←×≢f3~' '
          isQuo←   ('Q'∊f1) 
          isLit←  (('L'∊f1)∧isNotNull)∨isQuo
          isEval←  ('E'∊f1)∧isNotNull
           '⍝ ',f0 ⊣ DICT.Set f2  (HandleNL Parens∘DTB⍣(~isLit)⊣ isQuo CondQuotes isEval CondEval ProcWords f3)
      } ⍵
      CASE undefI: { 
          ¯1=⎕NC f1~'⎕': 11 ⎕SIGNAL⍨'XFIX :UNDEF ERROR: Invalid object name: "',f1,'"',CR,'[Line] ',f0
          extra←×≢f2
          extra: 11 ⎕SIGNAL⍨'XFIX :UNDEF ERROR: Trailing text not allowed: "',f2,'"',CR,'[Line] ',f0 
          '⍝ ',f0 ⊣ DICT.Del f1 
      } ⍵
      CASE wordI:   ProcWords f1   
  } ⍠OPTS 

  ProcWords←{
      pwReplCount pwReplMax← 1 20
      pwErrCount  pwErrMax←  0  1

      _ProcWords← sqP comP numP wordP ⎕R {
        wordI← 3
        ⍵.PatternNum≠wordI:  ⍵.Match
        old≡new← DICT.Get (old←⍵.(Lengths[1]↑Offsets[1]↓Block)): new 
        pwReplCount+← 1
        pwReplMax≥pwReplCount: _ProcWords new 
        new {
          pwErrCount+← 1
          pwErrMax<pwErrCount: ⍺ 
          ⎕←'>> XFIX WARNING: Replacement loop may not terminate: :DEFL ',⍵,' ',⍺
          ⍺ 
        } old 
      } ⍠OPTS

      _ProcWords ⍵
  }

⍝ procSpecials: 
⍝ processes...
⍝   Fns
⍝    dyadic  quote left   →  
⍝    monadic quote right  `
⍝    monadic sink         ←
⍝  system variable
⍝    sink name            ⎕T 
  tempsN←¯1
  specialPList← sqP comP numP sinkP tempP qLP qRP qRErrP 
  procSpecials← specialPList ⎕R { 
        sqI comI numI sinkI tempI qLI qRI qRErrI ← ⍳≢specialPList
        CASE←⍵.PatternNum∘∊
        CASE sqI comI numI: ⍵ Fld 0
        nm←'⍙T' 
        CASE sinkI:{
            f1← ⍵ Fld 1
            tempsN⊢←⊢ tempsN+1
            f1,nm,(⍕tempsN),'←' 
        } ⍵
        CASE tempI: {
          tempsN<0: 11 ⎕SIGNAL⍨'XFIX SINK ERROR: Sink Name (⎕T) not yet in use'
          nm, ⍕tempsN
        } ⍬
        CASE qLI qRI: (CASE qLI){
              bare← 0≠≢f1← ⍵ Fld 1  
              (' '/⍨⍺),(bare CondQuotes f1),⍺⊃  ' ' '(,⍥⊂)' 
        }⍵
        CASE qRErrI: 11 ⎕SIGNAL⍨'XFIX "QUOTE RIGHT" ERROR: Invalid use of `'
  } ⍠OPTS

  ∆UC ∆LC← (⎕A,⎕Á)(⎕C⎕A,⎕Á)
  ∆MC←∆UC,∆LC
  DICT←∆DICT  ('⎕LC'  '⎕UC' '⎕MC') (Quotes¨ ∆LC ∆UC ∆MC)
  res← procSpecials ProcMacros ProcStrings ⍵
  ×⍺: 2 ⎕FIX res ⋄ res 
}
