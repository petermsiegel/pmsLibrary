XFIX←{   
  ⍺←1
  DEBUG←1
  0/⍨~DEBUG:: ⎕SIGNAL/⎕DMX.(EM EN)
⍝ If ⍵ is a filename (char vector), process the file contents
  1≥|≡⍵: ⍺ ∇ ⊆⊃⎕NGET ⍵ 1
  ⎕IO← 0
  
⍝ ⍵ is (now or initially) a vector of lines (char vectors)

⍝ CONSTANTS
  SQ DQ←'''"' 
  NL←⎕UCS 10 
  DQ2←DQ,DQ
  QSEP←SQ,' ',SQ       ⍝ QSEP: Separates Two Quote Strings 
  OPTS←('UCP' 1)('Mode' 'M')('EOL' 'LF')

⍝ Utility Fns 
⍝ Fld: Select a numbered field of ⎕R namespace
  Fld← { o b l←⍺.(Offsets Block Lengths) 
         0≠0(≢o)⍸⍵: '' ⋄ ¯1≠off←⍵⌷o: len↑off↓b ⊣ len←⍵⌷l ⋄ ''  
  }
  AddSQs← { SQ,SQ,⍨∊(⊂QSEP)@(NL∘=)⊢⍵  }                     ⍝ Add single quotes to each quoted string...
  DQ2SQ←  { {⍵/⍨DQ2(~⍷)⍵}(⍵/⍨1+SQ=⍵) }                      ⍝ Internal double quotes to single quotes 
  Parens← '('∘,,∘')'
⍝ Regexp Alignment Fns 
⍝ AlignLeft: No Leading Blanks...
  AlignLeft←  '\n *' ⎕R '\n' ⍠OPTS
⍝ AlignMarg: In a multiline string, 
⍝            align subseq lines with the margin in the first line, ignoring an initial bare newline.
  AlignMarg← {
    isFirst margin skipNL1← 1 0 0
    ⍝ Initial bare newline is ignored...
    ⍝ Set left margin from first "full" line and align following with that.
      '\A(?=\n)' '\n( *)' ⎕R {
          0=⍵.PatternNum: '' ⊣ skipNL1⊢←1                    ⍝ We skip newline at <isFirst>
          nsp← ≢⍵ Fld 1
          isFirst: skipNL1↓NL ⊣ isFirst margin⊢← 0 nsp       ⍝ Set margin 
          NL,' '⍴⍨0⌈margin-⍨nsp                              ⍝ Align with margin         
      }⍠OPTS ⊢ ⍵ 
  }
  Strip1LR← 1↓¯1↓⊢
⍝ Strip trailing blanks from lines of multiline strings...
  StripTB← { NL(~∊)⍵: ⍵ ⋄ ' *\n'  ⎕R  '\n'  ⍠OPTS ⊢⍵ } 

⍝         sq str          dq str        comment    nl   all else 
  pats← '(''[^'']*'')+' '("[^"]*")+'  '⍝[^\n]*$' '\n' '[^''"⍝\n]+'
  ProcStrings← pats ⎕R { 
        sqI dqI←   0 1  
        CASE← ⍵.PatternNum∘∊
        f0← ⍵ Fld 0
        CASE sqI:  Parens AddSQs AlignLeft StripTB       Strip1LR f0 
        CASE dqI:  Parens AddSQs AlignMarg StripTB DQ2SQ Strip1LR f0
      ⍝ ELSE...
            f0 
  } ⍠OPTS  

  tempsN←0
  ProcTemps← '(''[^'']*'')+' '((?:[[{(⋄:\n]|^)\h*)←'  '⎕T\b' ⎕R { 
        CASE←⍵.PatternNum∘∊
        CASE 0: ⍵ Fld 0
        nm←'⍙T' 
        Txt← ⍕   ⍝ Or ,'ZI3'∘FMT
        Cyc← ⊢   ⍝ Or ... 1000∘| 
        CASE 2: nm,Txt tempsN
      ⍝ CASE 1:
            tempsN⊢←Cyc tempsN+1
            (⍵ Fld 1),nm,(Txt tempsN),'←' 
  } ⍠OPTS

  res← ProcTemps ProcStrings ⍵
  ×⍺: 2 ⎕FIX res ⋄ res 
}
