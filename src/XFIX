XFIX←{   
  ⍺←1
  DEBUG←1
  0/⍨~DEBUG:: ⎕SIGNAL/⎕DMX.(EM EN)
⍝ If ⍵ is a filename (char vector), process the file contents
  1≥|≡⍵: ⍺ ∇ ⊆⊃⎕NGET ⍵ 1
  ⎕IO← 0
  
⍝ ⍵ is (now or initially) a vector of lines (char vectors)

⍝ CONSTANTS
  SQ DQ←'''"' 
  NL←⎕UCS 10 
  DQ2←DQ,DQ
  QSEP←SQ,' ',SQ       ⍝ QSEP: Separates Two Quote Strings 
  OPTS←('UCP' 1)('Mode' 'M')('EOL' 'LF')

⍝ Utility Fns 
⍝ Fld: Select a numbered field of ⎕R namespace
  Fld← { o b l←⍺.(Offsets Block Lengths) 
         0≠0(≢o)⍸⍵: '' ⋄ ¯1≠off←⍵⌷o: len↑off↓b ⊣ len←⍵⌷l ⋄ ''  
  }
  AddSQs← { SQ,SQ,⍨∊(⊂QSEP)@(NL∘=)⊢⍵  }                     ⍝ Add single quotes to each quoted string...
  DQ2SQ←  { {⍵/⍨DQ2(~⍷)⍵}(⍵/⍨1+SQ=⍵) }                      ⍝ Internal double quotes to single quotes 
  Parens← '('∘,,∘')'
⍝ Regexp Alignment Fns 
⍝ AlignLeft: No Leading Blanks...
  AlignLeft←  '\n *' ⎕R '\n' ⍠OPTS
⍝ AlignMarg: In a multiline string, 
⍝            align subseq lines with the margin in the first line, ignoring an initial bare newline.
  AlignMarg← {
    isFirst margin skipNL1← 1 0 0
    ⍝ Initial bare newline is ignored...
    ⍝ Set left margin from first "full" line and align following with that.
      '\A(?=\n)' '\n( *)' ⎕R {
          0=⍵.PatternNum: '' ⊣ skipNL1⊢←1                    ⍝ We skip newline at <isFirst>
          nsp← ≢⍵ Fld 1
          isFirst: skipNL1↓NL ⊣ isFirst margin⊢← 0 nsp       ⍝ Set margin 
          NL,' '⍴⍨0⌈margin-⍨nsp                              ⍝ Align with margin         
      }⍠OPTS ⊢ ⍵ 
  }
  Strip1LR← 1↓¯1↓⊢
⍝ Strip trailing blanks from lines of multiline strings...
  StripTB← { NL(~∊)⍵: ⍵ ⋄ ' *\n'  ⎕R  '\n'  ⍠OPTS ⊢⍵ } 

⍝ Dictionary...
  InitKeys←{ 
      K←'Test' 'Test2'  '⎕ALPHA'
      V←'''This is it''' '(⍳10)' '⍺'
      K V 
  }
  GetKey←{ 
       K V←⍺ ⋄ k←1 ⎕C⍣('⎕'=⍬⍴⍵)⊢⍵ 
       p←K⍳⊂k  ⋄ p=≢K: ⍵ ⋄ p⊃V
  }

  sqP←   '(''[^'']*'')+'
  dqP←   '("[^"]*")+' 
  comP←  '⍝[^\n]*$'
  nlP←   '\n'
  elseP← '[^''"⍝\n]+'
  sinkP← '((?:^|[[{(⋄:\n])\h*)←' 
  tempP← '⎕T\b'
  keyWdP← '((¯?\d+[\.Ee¯\d]*)|⎕?[\w∆⍙](?<=\D)[\w∆⍙]*)(\h*→)?'

  ProcStrings← sqP dqP comP nlP elseP ⎕R { 
        sqI dqI←   0 1  
        CASE← ⍵.PatternNum∘∊
        f0← ⍵ Fld 0
        CASE sqI:  Parens AddSQs AlignLeft StripTB       Strip1LR f0 
        CASE dqI:  Parens AddSQs AlignMarg StripTB DQ2SQ Strip1LR f0
      ⍝ ELSE...
            f0 
  } ⍠OPTS  

  tempsN←0
  ProcTemps← sqP sinkP tempP keyWdP ⎕R { 
        sqI sinkI tempI keyWdI← 0 1 2 3
        CASE←⍵.PatternNum∘∊
        CASE sqI: ⍵ Fld 0
        nm←'⍙T' 
        CASE sinkI:{
            f1← ⍵ Fld 1
            tempsN⊢←⊢ tempsN+1
            f1,nm,(⍕tempsN),'←' 
        }⍵
        CASE tempI: nm, ⍕tempsN
        CASE keyWdI: {
              f1 f2 f3←⍵ Fld¨1 2 3
              isNum←    0≠≢f2 
              hasArrow← 0≠≢f3 
              ⎕←'f1="',f1,'" f2="',f2,'" f3="',f3,'"'
              hasArrow: {
                  isNum: f1,'(,⍥⊂)'
                  SQ,(f1/⍨1+SQ=f1),SQ,'(,⍥⊂)'
              }⍵
              isNum: f1 
            ⍝ Is a Keyword...
              { 
                ⎕←'Looking up "',⍵,'" in Dictionary'
                DICT GetKey ⍵ 
              }f1
        }⍵
  } ⍠OPTS

  DICT←InitKeys ⍬ 
  res← ProcTemps ProcStrings ⍵
  ×⍺: 2 ⎕FIX res ⋄ res 
}
