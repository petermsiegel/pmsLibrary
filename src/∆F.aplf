∆F←{ 
   ⍝ Simple format string function (PROTOTYPE)
  ⍝   [⍺←MODE DEBUG←1 0] ∆F 'format_string'  [⍹1 [⍹2 [... ⍹N]]]
  ⍝ For help, execute 
  ⍝   ∆F⍨'help'
  ⍝ or see ⍝H comments at the bottom of this function.

    ⍺←1 0
    'help'≡⍥⎕C⍕⍺: ⎕ED 'help'⊣help←↑'^\h*⍝H(.*)' ⎕S '\1'⊢⎕NR ⊃⎕XSI
    ×80|⎕DR ⊃⊆⍵: ⎕SIGNAL⊂ ('EM' '∆F DOMAIN ERROR') ('Message' 'Invalid format string') ('EN' 11)
    ⍲/(2↑⍺)∊¨1 0 ¯1,⍥⊂1 0: ⎕SIGNAL⊂('Message' ,⍥⊂'Invalid option/s (⍺): ',⍕⍺)('EN' 11 )
    
    (2↑⍺)((⊃⎕RSI){ 

    ⍝ Anonymous operator ∇∇: (⍺:Opts (⍺⍺:callerNS ∇∇ ⍵⍵:origOmega) ⍵:formatAsExecutableCode)
      0:: ⎕SIGNAL⊂ ⎕DMX.( ('Message' Message) ('EN' EN) ('EM' EM) )
      ⍝ If (⊃⍺)=1: execute ⍵ (format str=>code) with rt arg ⍵⍵ (caller's ⍵) in caller namespace ⍺⍺
        1=⊃⍺: ⍺⍺⍎⍵,'⍵⍵'  ⊣⍵⍵
      ⍝ Else (⊃⍺)∊0 ¯1: Return executable string (⍺=0) or pseudo-executable(⍺=¯1), passing orig. fmt str ⍵0   
        EnSQ← '''','''',⍨⊢(/⍨)1+''''∘=
        '{',⍵,(EnSQ ⊃⍵⍵),',⍥⊆⍵}'  

    }(,⊆⍵))(2↑⍺){

      0:: ⎕SIGNAL ⎕DMX.(⊂('EM' '∆F INTERNAL ERROR')('Message',⍥⊂EM{⍺,⍵,⍨': '/⍨0≠≢⍵}Message)('EN' 11))
        ⎕IO ⎕ML←0 1
        MODE DEBUG← ⍺  
      ⍝ Note pseudonames ⍙CHAIN, ⍙BOX, and ⍙OVER. These are not executed and only serve to show
      ⍝ what's happening when MODE option ¯1 is used.

      ⍝ CHAINdef (⍙CHAIN): horizontal field catenation
      ⍝   Used only in the preamble code as part of the generated output code (see below).
      ⍝   1. Converts ⍺ and ⍵ to char matrices a and w, and
      ⍝   2. Catenates a to left of w, aligning shorter to the height of the taller matrix
        CHAINdef← '⊃{⊃,/⍺ ⍵↑⍨¨⌈⍥≢/⍺ ⍵}⍥⎕FMT/'               ⍝ Executable code (for ⍺∊0 1).
        CHAINtok←  '⊃⍙CHAIN/'                               ⍝ Symbolic name, solely for code inspection (⍺=¯1).
      ⍝ $ (⎕FMT) shortcut (see below).
        FMTtok←  ' ⎕FMT ' 
      ⍝ $$ (⍙BOX: box display) shortcut (see below).
        BOXtok←'⎕SE.Dyalog.Utils.display ' ' ⍙BOX '⊃⍨¯1=MODE 
      ⍝ % (⍙OVER: vertical field catenation) shortcut (see below).
      ⍝   OVERDef: vertical field catenation [Experimental]
      ⍝   1. Converts ⍺, ⍵ to char matrices a and w (as needed), and 
      ⍝   2. Catenates a over w, centering and padding the narrow to the width of the wider matrix.
      ⍝ We insert it in place for each use (ugh) to avoid having to create/manage/name a library fn.
        OVERdef← '(⊃⍪/)⍤{T←↑⍤¯1⋄m←⌈/a b←⍺,⍥(⊃⌽⍤⍴)⍵⋄a b{⍺=m:⍵⋄m T⍵T⍨-⌊⍺+0.5×m-⍺}¨⍺⍵}⍥⎕FMT '
        OVERtok← ' ⍙OVER '                                  ⍝ Symbolic name, solely for code inspection (⍺=¯1).

      ⍝ Misc Util
        EnSQ← '''','''',⍨⊢(/⍨)1+''''∘=

      ⍝ Main Processing Routines: 
      ⍝ A. ProcTF   - Subprocess Text Fields
      ⍝ B. ProcCSF  - Subprocess Code and Space Fields
      ⍝ C. ProcAllF - Process All Fields
      ⍝ D. DivFStr2F- Divide Format String to Fields
      
      ⍝ A. ProcTF -  Subprocess Text Fields
      ⍝ Text Field Escapes  
        TFEsc← '(?<!\\)\\⋄'  '\\([{}\\])' ⎕R ('\r' '\\⋄' ⊃⍨¯1=MODE) '\1'  
      ⍝ ProcTF.  Process Text Fields
        ProcTF←   (' ',⊢)EnSQ⍤TFEsc 

      ⍝ B. ProcCSF - Subprocess Code and Space Fields
        ⍝ Code Field DQ String Escapes: See also ProcCSF. 
        esc2CrP←  '\\{2}⋄'
        esc1CrP←  '\\{1}⋄'
        unicodeP← '(\\{1,2})\{\h*(\d+)(?|\h*-\h*(\d+)|())\h*\}'
        ⋄ dqEscPats← esc2CrP esc1CrP unicodeP
        ⋄            esc2CrI esc1CrI unicodeI← ⍳≢dqEscPats
        DQEsc←  dqEscPats  ⎕R {
              Case← ⍵.PatternNum∘∊
              Fld←⍵.{Lengths[⍵]↑Offsets[⍵]↓Block}
              Case esc1CrI: CR '\\⋄'⊃⍨¯1=MODE   ⊣ CR←⎕UCS 13 
              Case esc2CrI: 1↓Fld 0 
            ⍝ Case unicodeI: Experimental
              2=≢Fld 1: 1↓Fld 0                          ⍝ If 2 \\, return match with just one.
            ⍝  \{mmm[-nnn]} returns ⎕UCS list in range mmm to nnn incl. (ascending or descending)
              beg end← (⊃∘⌽⎕VFI)∘Fld¨2 3 ⋄ 0=≢end:⎕UCS beg ⋄ ⎕UCS beg+(×∆)×⍳1+|∆←end-beg
        } 
        TrimR←    {⍵↓⍨-+/∧\⍺∊⍨⌽⍵}    
        dqP←      '(("[^"]*")+)' 
        sqP←      '((''[^'']*'')+)' 
        ⍝ $ and $$ shortcuts.  $: (1-,2-adic) ⎕FMT;  $$: (boxed) display.
        dolP←     '\h*(\${1,2})\h*'        
        ⋄ dolCodeV← FMTtok BOXtok
        ⍝ % Shortcut: Experimental
        pctP←     '\h*(\%{1})\h*'
        ⋄ pctCode←  OVERdef  OVERtok⊃⍨¯1=MODE
        ⍝ ⍹ Shortcut: ⍹N, ⍵N, ⍹, ⍵_
        omegaNP←  '[⍵⍹](\d+)'                              ⍝ ⍹N refers to the source Format string (N⊃⍵), for N a set of digits.
        omega0P←  '⍵_|⍹_?'                                 ⍝ ⍹ or ⍵_ means "next ⍹N". Starts at N=1.
        ⍝ ⍝ Comments: (limited pattern)
        comP←     '⍝[^}⋄]+' 
        ⍝                                   
        ⋄ csfPats← dqP sqP comP dolP pctP omegaNP omega0P 
        ⋄          dqI sqI comI dolI pctI omegaNI omega0I←⍳≢csfPats
        ∆OMEGA←0
        ProcCSF←  {
            code←  csfPats ⎕R {
                ⋄ Case← ⍵.PatternNum∘∊
                ⋄ Fld←  ⍵.{Lengths[⍵]↑Offsets[⍵]↓Block}
                Case dqI:     ' ',EnSQ DQEsc 1↓¯1↓Fld 0        ⍝ DQ String: Escapes applied
                Case sqI:     Fld 0                            ⍝ SQ String: No Escapes applied
                Case comI:    ''
              ⍝ $: ⍺ ⎕FMT ⍵, $$: (box) display: of ⍵ (⍺ ignored)
                Case dolI:    dolCodeV ⊃⍨ 2=≢Fld 1  
              ⍝ %: vertical centered catenation of ⍺ over ⍵
                Case pctI:    pctCode
              ⍝ Getting ⍹N sets ∆OMEGA←N and returns N⊃⍵ in code form.
                Case omegaNI: '(⍵⊃⍨⎕IO+',')',⍨F1         ⊣  ∆OMEGA⊢← ⊃⌽⎕VFI F1←Fld 1   
              ⍝ Getting ⍹ (⍵_) increments ∆OMEGA and returns ∆OMEGA⊃⍵ in code form.            
                Case omega0I: '(⍵⊃⍨⎕IO+',')',⍨⍕∆OMEGA    ⊣  ∆OMEGA+← 1   
            } 1↓¯1↓⍵                                           ⍝ Remove { and }
          ⍝ Self-documenting mode: Trailing right arrow → makes this a self-documenting code field.
            trim←  ' ⋄' TrimR code   
            '→'≠¯1↑trim:  '({', code,'}⍵)' 
          ⍝ doc:  literal "code" entered, including → and blanks around →.
          ⍝ flds: just the executable code sans →, blanks, and comments.
            doc code← (1↓¯1↓⍵) (¯1↓trim)
            ( ' ',EnSQ doc )  (' ({', code, '}⍵)')    
        }
          
      ⍝ C. ProcAllF. Process all fields by type.
      ⍝ Returns at least 2 fields (null ones if required), as required by CHAINdef (which see).
        ⋄  Pad2F←  ⊢,⍨ '⍬'⍴⍨ 0⌈ 2-≢    
        ⋄  DbgBox← { ~DEBUG: ⍵ ⋄ '(',BOXtok,⍵,')' }               
        ⋄  Scal2V← '(,',')',⍨⊢                                ⍝ Useful with DEBUG (box display) option
        ProcAllF←  Pad2F DbgBox∘{ '{'=1↑⍵:  ProcCSF ⍵  ⋄ sc←DEBUG∧1=≢⍵ ⋄ Scal2V⍣ sc⊢ ProcTF  ⍵ }¨

      ⍝ D. DivFStr2F: Divide format string into fields (convert space fields to simple code fields)
      ⍝ Returns: A set of fields, each as a char vec. 
        ⍝ Null fields-- generated by 0-width Space Fields {} or 0-width Text Fields-- are suppressed.
          ⋄ DelNullF←  ⊢(/⍨)0∘≠⍤≢¨                             ⍝ Omit null fields before processing. 
        ⍝ Space Fields handled before Code Fields: simpler, non-recursive patterns.
        ⍝ spaceNullP: {} or {:0:} ==> generates no code.
          spaceNullP← '(?x) \{ (?: \h* : 0* :? \h* )? \}'      ⍝ Null Space Field: Separates fields.   
          ⋄ spExtras←'((→\s*)?(⍝([^}⋄])*)?)'                   ⍝ Self Documenting Code and Comment subpatterns
        ⍝ space1P: {     } ==>  'ssss', ssss is 1 or more spaces. Also generates spExtras if used.
          space1P←  '(?x) \{       ( \s*                  )        ',spExtras,' \}'    
        ⍝ space2P: { :n: } ==>  (' '⍴⍨nn), nn=# spaces.           Also generates spExtras if used.
          space2P←  '(?x) \{ \s* : ( \d+ | [⍵⍹](?:\d+|_)? ) :? \s* ',spExtras,' \}'     
        ⍝ codeP: Recursively matches balanced braces {}, handling DQ strings, escapes \{, limited comments, etc.
          codeP←   '(?x) (?<P> (?<!\\) \{ (?>  [^{}"⍝\\]+ | (?:\\.)+ | (?:"[^"]*")+ | ⍝[^}⋄]* | (?&P)* )+  \} )' 
          divPats←  spaceNullP space1P           space2P             codeP 
          divRepl←  '\r'       '\r{,''\1''\2}\r' '\r{\1⍴'' ''\2}\r'  '\r\0\r'
        DivFStr2F← DelNullF divPats ⎕R divRepl
          
      ⍝ Executive 
        ⋄ AddPreamble← '{','}',⍨ (CHAINdef CHAINtok⊃⍨¯1=MODE), ∊ 
        AddPreamble ProcAllF DivFStr2F ⊆⊃⍵
    }⊆⍵  

  ⍝H ∆F: Simple format string function in an APL style, inspired by F Strings in Python.
  ⍝H ⍺:options ∆F format_string args
  ⍝H      format_string: A string containing code and text to display a mixture of APL objects easily.
  ⍝H      args:          O or more "arguments" that can easily incorporate values into the format string.
  ⍝H      options:       [ [MODE=1|0|¯1] [DEBUG=0|1]  | 'help' ]
  ⍝H ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨↑¨¨¨¨¨¨¨¨¨¨¨¨¨¨↑¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  ⍝H   ⍺:options    ∆F Returns 
  ⍝H   MODE=1       A char matrix based on the format string and subsequent values of ⍵. (Default mode).
  ⍝H                In this mode, all 2D fields are chained together, left to right.
  ⍝H   MODE=0       A char vector, representing an executable dfn in string form
  ⍝H                (which can be established via MyFmtDfn← ⍎0 ∆F myFmtStr)
  ⍝H   MODE=¯1      A char vector representing the formatting as a pseudo-code string,  
  ⍝H                suitable for inspection, debugging, etc.
  ⍝H ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  ⍝H   DEBUG=0      Each field is displayed normally (and returned per MODE). Default.
  ⍝H   DEBUG=1      Each field  will be displayed in a 2D box (and returned per MODE). 0-width fields are omitted.
  ⍝H ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  ⍝H   ⍺≡'help'     An empty char vec (''). See HELP
  ⍝H ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  ⍝H EXAMPLES
  ⍝H Example 1a:  Text Fields and Code Fields {...} with simple variables.
  ⍝H        names←  ↑'John Jones'  'Mary Smith'
  ⍝H        addr←   ↑'1214 Maiden Ln'  '24 Hersham Rd'
  ⍝H        ∆F 'Name: {names}  Addr: { addr }'
  ⍝H     Name: John Jones  Addr: 1214 Maiden Ln
  ⍝H           Mary Smith        24 Hersham Rd 
  ⍝H 
  ⍝H Example 1b: Self-documenting Expressions {...→} in Code Fields.
  ⍝H     ⍝ Same definitions as above. (Extra space after → reflected in the output)
  ⍝H        ∆F '{names→}  { addr→}'
  ⍝H     names→John Jones   addr→1214 Maiden Ln  
  ⍝H           Mary Smith        24 Hersham Rd 
  ⍝H
  ⍝H Example 1c: Titles (using the OVER shortcut %)
  ⍝H     ⍝ Same definitions as above.  
  ⍝H        ∆F '{"Name"%names}  {"Address"%addr}'
  ⍝H        Name        Address    
  ⍝H     John Jones  1214 Maiden Ln
  ⍝H     Mary Smith  24 Hersham Rd 
  ⍝H
  ⍝H Example 2: Calculations and Formatting ($, short for ⎕FMT) in Code Fields
  ⍝H       c←  100 20 12 23 ¯2
  ⍝H       F←  32+1.8∘×
  ⍝H     ⍝ 2a: Format specification as an argument ⍵1, i.e. (1+⎕IO)⊃⍵. (Degree sign (°): ⎕UCS 176)
  ⍝H       ∆F '{ ⍵1 $ c }C = { ⍵1 $ F c }F' 'I3,⊂°⊃'   ⍝ Result is a 5-row 15-col char matrix.
  ⍝H  100°C =  212°F
  ⍝H   20°      68°              
  ⍝H   12°      54°              
  ⍝H   23°      73°              
  ⍝H   ¯2°      28°  
  ⍝H     ⍝ 2b: Format specification hard-wired in Code Field. 
  ⍝H     ⍝     Note alternative way to enter '°' as unicode 176 (in decimal).
  ⍝H       ∆F '{ "I3,⊂°⊃" $ c }C = { "F5.1,⊂\{176}⊃" $ (32+1.8∘×) c }F'  
  ⍝H  100°C = 212.0°F
  ⍝H   20°     68.0° 
  ⍝H   12°     53.6° 
  ⍝H   23°     73.4° 
  ⍝H   ¯2°     28.4° 
  ⍝H     ⍝ 2c: Variant on (2b) with a header for each Code field using the % (OVER) shortcut.
  ⍝H       ∆F'{"Celsius" % "I3,⊂°⊃" $ c }  { "Fahren." % "F5.1,⊂°⊃" $ (32+1.8∘×) c }'
  ⍝H  Celsius  Fahren.
  ⍝H   100°    212.0° 
  ⍝H    20°     68.0° 
  ⍝H    12°     53.6° 
  ⍝H    23°     73.4° 
  ⍝H    ¯2°     28.4° 
  ⍝H
  ⍝H Example 3: DEBUG(/BOX) display option (1=⊃⌽⍺)
  ⍝H     ⍝ Displays each field in its own "box" (ignoring null (0-width) fields)
  ⍝H       1 1 ∆F 'one{}{}{ }two {"two"}{:0}{ }three'  
  ⍝H   ┌→──┐┌→┐┌→───┐┌→──┐┌→┐┌→────┐
  ⍝H   │one││ ││two ││two││ ││three│
  ⍝H   └───┘└─┘└────┘└───┘└─┘└─────┘
  ⍝H     ⍝ Without DEBUG option.
  ⍝H       ∆F 'one{}{}{ }two {"two"}{:0}{ }three' 
  ⍝H   one two two three
  ⍝H 
  ⍝H HELP
  ⍝H ¯¯¯¯
  ⍝H For help, enter
  ⍝H   ∆F⍨'help'
  ⍝H
  ⍝H A. The ∆F Format String (⍹0)
  ⍝H ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
  ⍝H The format_string is a character vector defining 0 or more 2-D (Char Matrix) "fields," 
  ⍝H which are executed right to left (as in APL) and assembled into a single matrix (with fields top-aligned).
  ⍝H
  ⍝H There are 3 types of fields generated: 
  ⍝H    1. Code Fields, 2. Space Fields, and 3. Text Fields.
  ⍝H
  ⍝H 1. Code Fields
  ⍝H    Code Fields are essentially dfns and may contain any dfn code, including error handling. 
  ⍝H    Each Code field has implicit right arguments, those passed to ∆F as ⍵ when executed.
  ⍝H 
  ⍝H    Special Variables ⍹0,⍹, etc., used in Code Fields*
  ⍝H    ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯       * See also usage in Space Fields.
  ⍝H       ⍹0, ⍹1, ... ⍵N, denote the scalars in the right arg (⍵) passed to ∆F. 
  ⍝H       ⍹ is the glyph ⎕UCS 9081.
  ⍝H       ⍹0: (0⊃⍵) the format string itself (0 given ⎕IO=0). It may only be referenced explicitly.
  ⍝H       ⍹1: (1⊃⍵) the first scalar after the format string. 
  ⍝H       ⍹N: (N⊃⍵) the Nth scalar after the format string.
  ⍝H       ⍹:  [⍹ with no digits immed following]
  ⍝H           selects the "next" scalar to the right, starting AFTER the format string with ⍹1.
  ⍝H        ∘  ⍹ is incremented by 1 for each use. 
  ⍝H        ∘  Resetting ⍹:  
  ⍝H           * If  ⍹N is used in a Code Field, the next ⍹ is ⍹N+1;
  ⍝H           * If more than one  expression ⍹N, ⍹P, ⍹Q appears in a Code Field, 
  ⍝H             the rightmost determines the next ⍹ (here ⍹Q+1).
  ⍝H        ∘  NB: the initial value of ⍹ is ⍹1, not ⍹0. (⍹0 must be referenced explicitly)
  ⍝H        ∘  Easy to type alternatives to using the glyph '⍹' :
  ⍝H           FOR                    USE
  ⍝H           ⍹0, ⍹1, ... ⍹N         ⍵0, ⍵1, ... ⍵N
  ⍝H           bare ⍹                 ⍵_ 
  ⍝H        ⍵  What about ⍵ (no numeric suffix or _)?
  ⍝H           ⍵ by itself has its normal dfn interpretation, i.e. the set of 0 or more scalars: ⍹0 ⍹1 ... ⍹N.
  ⍝H    {ccc} Code Field  
  ⍝H     ccc  any dfn code, including multiple stmts, guards, and error guards.
  ⍝H        ∘ Code ccc is executed and the result is formatted via ⎕FMT.
  ⍝H        ∘ \{ and \} (escaped with backslash (\)) do not start or end code fields (see Text Fields).
  ⍝H        ∘ To enter quoted strings in Code Fields, use double quotes "like these":
  ⍝H          - {⎕NC "fred"} is easier than {⎕NC ''fred''}
  ⍝H          - In a code field, there are a few escape sequences within double-quoted strings ONLY. 
  ⍝H            Outside of these, backslashes (\) are as in std APL.
  ⍝H               \⋄         indicates a carriage return ("newline"). It is not replaced if MODE=¯1.
  ⍝H               \\⋄        indicates '\⋄'
  ⍝H               \{nnn}     indicates (⎕UCS nnn), where nnn consists of 1 or more digits (ok w/ lead/trail spaces).
  ⍝H               \{nnn-mmm} (no preceding backslash (\))
  ⍝H                          indicates unicode chars from nnn to mmm inclusive, where mmm is as for nnn.
  ⍝H                  Ex. ∆F '"{"\{97-109}...\{57-48}"}"' 
  ⍝H                  ==>     "abcdefghijklm...9876543210"
  ⍝H               In DQ strings, "\⋄" is the same as "\{13}".
  ⍝H                  Ex. ∆F '{"Dogs\⋄Cats"} vs {"Dogs\{13}Cats"}'
  ⍝H                  ==>      Dogs vs Dogs
  ⍝H                           Cats    Cats 
  ⍝H               \\{nnn-mmm} indicates the string \{nnn-mmm}, i.e. with the extra \ removed.
  ⍝H               Any other variant of \{...} is NOT treated as special: "\{123+⍳5}" ==> "\{123+⍳5}".
  ⍝H          - Note: Otherwise, \ is NOT special, i.e. is kept as is. "abc\def" => "abc\def", NOT "abcdef".
  ⍝H        ∘ To include a double quote (") within a double-quoted string, enter the APL way:
  ⍝H             "abc""def""ghi"  ==>   abc"def"ghi
  ⍝H        In a code field (outside strings)
  ⍝H        ∘ $ is a special symbol for ⎕FMT to allow easy formatting (using the dyadic variant):
  ⍝H             {"F8.2" $ MyCode...}       ⍝ Same as {"F8.2" ⎕FMT MyCode...}
  ⍝H        ∘ $$ is a special symbol for the display function (from the DFNS ws), which causes code to 
  ⍝H          be displayed in a box:
  ⍝H             { $$ MyCode...} 
  ⍝H        ∘ $$ and Dyadic $ used together may be useful:
  ⍝H             { $$ "F8.2" $ MyCode}    ⍝ $ Formats then $$ puts in a box.
  ⍝H        ∘ % is a special symbol for placing one ⎕FMT-able object over another, each centered.
  ⍝H          - Each object is converted to a char. array (if not already), padding if necessary, 
  ⍝H            then glued the left (⍺) OVER the right (⍵).
  ⍝H          - The % (OVER) option is useful for titles or for building hierarchical displays without
  ⍝H            doing all the gluing yourself.
  ⍝H          - See the example above.
  ⍝H        ∘ A Code Field may include limited comments, 
  ⍝H          beginning with a '⍝' and terminated just before the next '⋄' or '}' on the same line.
  ⍝H          Braces, statement ends (⋄) and (double) quotes are not allowed in Code Field comments.
  ⍝H     {ccc →} A Self-documenting Code Field
  ⍝H        A Code Field with a trailing right arrow (→) will generate two fields:
  ⍝H        ∘ the code itself in literal form, followed by its evaluated value:
  ⍝H          ∆F'A: {⍪⍳⍵1 →},  B: {⍪⍵2+⍳⍵1 →}' 2 3
  ⍝H          A: ⍪⍳⍵1 → 0,  B: ⍪⍵2+⍳⍵1 → 3
  ⍝H                    1                4
  ⍝H        ∘ Extra blanks and comments are allowed within a Self-documenting Code Field and
  ⍝H          will appear in the output.
  ⍝H             ∆F'⎕IO={⎕IO}. {⍪⍳⍵1 → ⍝ SIMPLE }  {⍪⍵2+⍳⍵1 → ⍝ FANCY }' 2 3
  ⍝H          ⎕IO=0. ⍪⍳⍵1 → ⍝ SIMPLE 0  ⍪⍵2+⍳⍵1 → ⍝ FANCY 3
  ⍝H                                 1                    4
  ⍝H
  ⍝H 2. Space Fields
  ⍝H    {sss | :nn: | :⍹N:} Space Field   
  ⍝H     sss  0 or more spaces, inserts spaces indicated
  ⍝H     nn   a positive number of one or more digits, inserts nn spaces. 
  ⍝H     ⍹N   a special variable ⍹1, ⍹9, ⍹, ⍵_, etc. (See above)
  ⍝H
  ⍝H     For Numeric or Special Variable Space Fields
  ⍝H     ∘ The colon prefix is required;  the colon suffix is optional.
  ⍝H     ∘ An ill-formed Space Field will be handled as a Code Field, likely triggering an error.
  ⍝H     ∘ Only one Special Variable is allowed (i.e. ⍹5 or ⍹, but not ⍹4+⍹5, etc.)
  ⍝H
  ⍝H     A 0-width Space Field {} is handy as a separator between multiline Text Fields (see below).
  ⍝H
  ⍝H 3. Text Fields
  ⍝H    Everything else is a Text Field
  ⍝H    ∘ Text fields may contain newlines as \⋄. Simple ⋄ is not special.
  ⍝H      To show \⋄, enter \\⋄.  To show { or }, enter \{ or \}. 
  ⍝H      In all other cases, simple \ is not special: +\ is simply +\.
  ⍝H    ∘ You can use {} to separate Text Fields.
  ⍝H      {} is a 0-width Space Field (see 2. Space Fields above).
  ⍝H      EXAMPLE: 
  ⍝H        Compare these two cases, the first with {} separating 2 multiline Text Fields:
  ⍝H           ∆F 'One\⋄two{}-Three\⋄-four'  vs    ∆F 'One\⋄two-Three\⋄-four' 
  ⍝H        One-Three                           One
  ⍝H        two-four                            two-Three
  ⍝H                                            -four
  ⍝H
  ⍝H B. ∆F Options:  ⍺[0] (default ⍺[0]=1)  MODE Option
  ⍝H                 ⍺[1] (default ⍺[1]=0)  DEBUG (BOX) Option
  ⍝H ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
  ⍝H For format string fs there are three modes, determined by ⍺[0]= 1, 0, or ¯1.
  ⍝H
  ⍝H ⍺[0]  MODE Option
  ⍝H ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  ⍝H [1]   ∆F IMMEDIATE MODE
  ⍝H ⍺[0]=1   1 ∆F fs ⍵1 ⍵2 ... ⍵N          ⍝ ⍺=1 is the default
  ⍝H     ∘ Executes the format string fs, implicitly passing any scalars ⍵1...⍵N to the right as arguments.
  ⍝H     ∘ Note: Variables and settings seen are those of the CALLING environment where ∆F is executed.
  ⍝H       Returns: a char matrix consisting of the fields built per the format and scalars passed.
  ⍝H
  ⍝H [0]   ∆F CODE GENERATION MODE
  ⍝H ⍺[0]=0   0 ∆F fs
  ⍝H     ∘ Generates a code string CS that can be executed (without repeatedly calling ∆F to reparse fs) as 
  ⍝H         (⍎CS) ⍵1 ⍵2 ... ⍵N   or   Dfn←⍎C                ⍝ (⍎CS) or Dfn is an executable dfn...
  ⍝H                                   Dfn ⍵1 ⍵2 ... ⍵N
  ⍝H       where the args ⍵1...⍵n will be combined at EXECUTION time with fs as (fs,⍥⊆⍵1...⍵N), 
  ⍝H         where fs, the format string text originally passed to ∆F, is automatically assigned to ⍹0, as expected.
  ⍝H     ∘ Note: Variable and fn names in Code Fields are resolved in the calling environment when (⍎C) is executed;
  ⍝H         a different namespace "ns" may be specified via (ns⍎C), a standard feature of execute (⍎).
  ⍝H     ∘ Returns: a char vector representing an executable dfn with results identical to 
  ⍝H         1 ∆F fs ⍹1 ⍹2 ... ⍹N
  ⍝H
  ⍝H [¯1]  ∆F PSEUDOCODE MODE
  ⍝H ⍺[0]=¯1  ¯1 ∆F fs
  ⍝H     ∘ Generates a pseudo-executable P, which is identical to X, except
  ⍝H       - the internally used catenation function is abbreviated to the symbolic function name ⍙CHAIN,
  ⍝H       - newline escapes \⋄ are maintained as \⋄, suppressing
  ⍝H         multiline output, so the pseudocode can be easily inspected.
  ⍝H     ∘ Returns: a char vector of pseudocode.
  ⍝H
  ⍝H ⍺[1]  DEBUG (BOX) Option
  ⍝H ¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨¨
  ⍝H ⍺[1]=0 DEFAULT (NOBOX) Setting
  ⍝H     ∘ Output displayed normally, without extra boxing.
  ⍝H 
  ⍝H ⍺[1]=1 DEBUG (BOX) Setting
  ⍝H     ∘ Output is displayed with each field shown within its own box, whether a text, space, or code field.
  ⍝H     ∘ Any null fields generated (0-width) are suppressed, i.e. not shown at all in the output.
  ⍝H     ∘ DEBUG/BOX mode is useful for verifying the expected output format is achieved for each input field. 
  ⍝H 
  ⍝H PERFORMANCE
  ⍝H ¨¨¨¨¨¨¨¨¨¨¨
  ⍝H As a prototype, ∆F is relatively slow, but serviceable enough. Where important, e.g. in loops, 
  ⍝H scan (compile) the format string before the loop and then run the resulting dfn (here: Fmt1):
  ⍝H      ⍝ In a TRADFN                      ⍝ In a DFN
  ⍝H        Fmt1← ⍎0 ∆F '{...}...{}...{}'      Fmt1← ⍎0 ∆F '{...}...{}...{}' 
  ⍝H        :FOR i :IN ⍳Whatever               { 0=⍵: _←⍺
  ⍝H             ... do stuff ...                  ... do stuff ...
  ⍝H             Fmt1 arg1 arg2 ...                ⎕←Fmt1 arg1 arg2 ⋄ ⍺ ∇ ⍵-1
  ⍝H        :ENDFOR                            }⍨ Whatever
  ⍝H
  ⍝H Tentative Relative ∆F Timings* of Immediate Mode vs Code Gen (Compiled) Mode
  ⍝H ¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
  ⍝H      ∆F fmt ⍵1 ⍵2 ...     100%  COMPILE → CODE STR → DFN → RUN      ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
  ⍝H CS←  0 ∆F fmt              85%  COMPILE → CODE STR                  ⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕⎕
  ⍝H DFN← ⍎CS                    4%            CODE STR → DFN            ⎕
  ⍝H DFN ⍵1 ⍵2 ...              11%                             RUN      ⎕⎕⎕
  ⍝H -----------
  ⍝H [*] Test had six fields, exhibiting a range of field types. ∆F strings are typically small in size and number.
  ⍝H
}
