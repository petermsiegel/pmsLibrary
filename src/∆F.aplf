âˆ†Fâ†{ 
â Simple formatting  function in APL style, inspired by Python f-strings.
â Syntax: [opts] âˆ†F f-string  args
â        f-string: char vector with formatting specifications
â        args: arguments visible to f-string code expressions 
â              â¹1=1st arg after f-string (â•IO independent)
â        opts: [MODE BOX NSâ†1 0 0 | 'help' | â¬]
â For help, execute 
â   âˆ†Fâ¨'help' ... or see âH "HELP" comments at the bottom of this function.
â See help PDF at:
â   https://drive.google.com/file/d/1x82YiNDTHlw0uMFgcElIRSFfK_PnLeOq/view
â For internal error handling, 
â   See I. F-string Processing Function (I.A. Setup).

â Metaconventions Used Here...
â   Name Templates: FnName; varName; â™PSEUDO_SYS_OBJ; _tempVar; _TempFn...
â   Class Suffixes: P=regexp pattern; R=regexp result; G=Global (within this fn); I=small int const.; 
â                   C=code str; Opt=option; OptS=option spec; Nm=obj namestring;
â   Other Abbrev:   TF=Text Field; CF=Code Field; SF=Space Field; CSF=Code or Space Field;
â                   DQ=double quotes or DQ strings; SQ=single quotes...

    âºâ†1 0 0 0
  â¬â‰¡âº: _â†1 0â´'' 
â HELP:   Use 1) External URL and Ride for HELP vs 2) Basic Help generated internally
 'help'â‰¡â•C âº: 1 0â´''âŠ£ 'HELP:RIDE' {     
    2::  â•ED 'help'âŠ£helpâ†â†‘'^\h*âH(.*)' â•S '\1'âŠ¢â•NR âµ  
    â Google Drive URL...
      helpUrlâ† '"https://drive.google.com/file/d/', '/view?usp=sharing"',â¨ '1x82YiNDTHlw0uMFgcElIRSFfK_PnLeOq'
    â Send URL to Dyalog Ride.  <meta...> displays the requested URL immediately... 
      'HELP:RIDE'â‰¡âº: 'âˆ†F HELP' (3500âŒ¶) ('<meta http-equiv="Refresh" content=''0; url=',helpUrl,''' />') 
      âˆ˜ğŸ˜€ğŸ˜€'HELP:BASIC'ğŸ˜€ğŸ˜€âˆ˜  â Default and on error       
    }âŠƒâ•XSI 

  â Phase II. F-string Exec. Operator: 
  â    MODE
  â    1   Execute executable in caller NS, Return formatted mx result
  â    0   Generate executable string,      Return it
  â   Â¯1   Generate Pseudo-code string      Return it
  â    Syntax: âº (âºâº âˆ‡âˆ‡ âµâµ) âµ
  â      âº:   MODE  (orig. âŠƒâº)    âºâº:  offset in â•RSI to caller namespace (default: 0)
  â      âµâµ:  orig. âµ              âµ:  executable based on input f-string

    (âŠƒâº)((âŠƒ3â†“âº){    â âºâº â† (3âŠƒâº) if (4=â‰¢âº), else 0.  [â•IOâ†0]
     0 1000::â•SIGNALâŠ‚â•DMX.('EN' 'EM' 'Message',â¥âŠ‚Â¨(999âŒŠEN)('âˆ†F ',EM)Message) 
    â MODE=1  (immediate execution)  
      (1=âº) âˆ§ 0=âºâº:      (âŠƒâ•RSI) ââµ,'âµâµ' âŠ£âµâµ    
      (1=âº) âˆ§ 9=â•NC'âºâº': âºâº      ââµ,'âµâµ' âŠ£âµâµ     
       1=âº:              â•SIGNAL/'âˆ†F DOMAIN ERROR: Invalid option (caller NS)' 11  
    â MODEâˆŠ0 Â¯1    (generate and return code string; generate pseudo-code)
        errCâ† '0 1000::â•SIGNALâŠ‚â•DMX.(''EN'' ''EM'' ''Message'',â¥âŠ‚Â¨(999âŒŠEN)(''âˆ†F '',EM)Message)â‹„' 
        WrapSQâ† '''','''',â¨âŠ¢(/â¨)1+''''âˆ˜=
        '{', (errC/â¨ 0â‰¤âº), âµ, (WrapSQ âŠƒâµâµ),',â¥âŠ†âµ}'  
    }(,âŠ†âµ))âº{ 

  â Phase I.  F-string Processing Function
  â      Returns executable based on input f-string to anon dfn "I. (F-string Exec. Operator)"
  â      Syntax:  âº âˆ‡ âµ   (âº as from caller; âµ is âŠ†âµ from caller).
  â   I.A. Setup
  â   I.B. Processing Tokenized Fields
  â   I.C. Tokenizing F-string to Fields
  â   I.D. Executive
  
  â I.A. Fn Setup: Error Handling, Option Flags, Shortcut/Option Code Strings
        â•IO â•MLâ†  0 1
        cOS1â†1+cOSâ†â‰¢dOSâ† (Â¯1 0 1)(1 0)(1 0)            â Option (âº) specifications. We don't validate 3âŠƒâº here.
        Errâ† âŠ‚'EN' 'EM' 'Message',â¥âŠ‚Â¨âŠ¢                 â âº/âµ Error Handling...
      ((cOS1<â‰¢)âˆ¨(1<â´âˆ˜â´)âˆ¨(1<|âˆ˜â‰¡))âº:    â•SIGNAL Err 11 'âˆ†F DOMAIN ERROR' 'Invalid option'            
      ~âˆ§/dOSâˆŠâ¨Â¨âºâ†‘â¨cOS:                â•SIGNAL Err 11 'âˆ†F DOMAIN ERROR' 'Invalid option'            
      ((1<â´âˆ˜â´)âˆ¨(Ã—80|â•DR))âŠƒâµ:          â•SIGNAL Err 11 'âˆ†F DOMAIN ERROR' 'Invalid f-string'
                                                       â â†“ Unexpected Errors...
      0:: â•SIGNAL Err 11 'âˆ†F INTERNAL ERROR', {âº,âµ,â¨': '/â¨0â‰ â‰¢âµ}/ â•DMX.(EM Message)  
   
        modeOpt boxOpt nsOptâ† 3â†‘âº                      â Option Flags (âº)   
        isPseudoâ† â¬â´modeOpt<0                          â isPseudo: PSEUDO-CODE Mode   

        SetCodeVarsâ†{ isPs bxFnNmâ† âµ
          â codeVars6â†  âˆ‡ isPseudo bxFnNm 
          â Note required padding with blanks, where code not otherwise prefixed or suffixed with non-alph sep chars
          â â... means a pseudo-system fn. Just for show.
          isPs:  ' â•FMT '   '  âBOX '    ' âBOXM '  ' âOVER ' ' âCHAIN ' 'âŠƒâCHAIN/'
            3â‰ â•NC bxFnNm: 6 â•SIGNALâ¨'âˆ†F VALUE ERROR: Utility "',bxFnNm,'" not found.'
              _â† âŠ‚  ' â•FMT '                                â â•FMT:     Format obj âµ
              _,â†âŠ‚ ' ',bxFnNm,' '                           â âBOX:     Box obj âµ
              _,â†âŠ‚ '(''Â·''@('' ''=âŠ¢))',bxFnNm,' '           â âBOXM:    Box obj âµ and replace spaces with middle dots
                _oCâ†'(âŠƒâª/)â¤{Tâ†â†‘â¤Â¯1â‹„mâ†âŒˆ/wâ†âº,â¥(âŠƒâŒ½â¤â´)âµâ‹„w{âº=m:âµâ‹„m TâµTâ¨-âŒŠâº+2Ã·â¨m-âº}Â¨âºâµ}â¥â•FMT '
              _,â†âŠ‚ _oC                                      â âOVER:    Place matrix-âº over matrix-âµ
              _,â†âŠ‚  '{âŠƒ,/âºâµâ†‘â¨Â¨âŒˆâ¥â‰¢/âºâµ}â¥â•FMT '                â âCHAIN:   Chain matrix-âº to left of matrix âµ
              _,â†âŠ‚ 'âŠƒ{âŠƒ,/âºâµâ†‘â¨Â¨âŒˆâ¥â‰¢/âºâµ}â¥â•FMT/âŒ½'               â âŠƒâCHAIN/: Chain together list of matrices-âµ left to right
              _
        } 
        fmtC boxFnC boxModeC overC chainC chainFoldCâ† SetCodeVars isPseudo 'â•SE.Dyalog.Utils.display' 
  
  â I.B. Process Tokenized Fields
  â   I.B.0. Setup / Shared Defs, e.g. define IsCSF (what's a code or space field), IsSF (what's a space field)
  â   I.B.1. ProcTF       - Process Text Fields
  â   I.B.2.              - Process Code and Space Fields
  â      I.B.2a. DQStrEsc    - Process Code Field DQ String Escapes 
  â      I.B.2b: ProcCSF     - Process Code/Space Fields
  â   I.B.3. ProcFlds     - Process All Fields    
        
      â I.B.0 (Setup / Shared Defs)
        â Miscellany
          WrapSQâ†  '''','''',â¨âŠ¢(/â¨)1+''''âˆ˜=            â Double the SQs in âµ and wrap âµ in SQs.
          WrapPrnâ† '(',')',â¨âŠ¢                          â Wrap âµ in parens.
        â Field Tests: Test for combined CSF (Code/Space Fields) and SF (Space Fields)  
          IsCSFâ† âŠƒâˆŠâˆ˜(â•UCS 0 1)  â   \x{0} or \x{1}     â See TagTF/SF/CF and Tok2Flds below.
          IsSFâ†  âŠƒ=âˆ˜(â•UCS 1)    â   \x{1}   
        â Fields Tags: Tag (â•R result) field string âµ and append with field boundaries... 
        â ... as a Text (TF), Space (SF), or Code Field (CF).               
          TagTFâ† '\r',     '\r',â¨âŠ¢                     â TF: empty tag
          TagSFâ† '\r\x{1}','\r',â¨âŠ¢                     â SF: â•UCS 1
          TagCFâ† '\r\x{0}','\r',â¨âŠ¢                     â CF: â•UCS 0

      â I.B.1. Process Text Fields
      â   ProcTF   
          ptfPâ†  '(?<!\\)\\â‹„'  '\\([{}\\])'
          ptfRâ†  ('\r' '\\â‹„' âŠƒâ¨isPseudo) '\1'  
        ProcTFâ† (' ',âŠ¢)WrapSQâ¤(ptfP â•R ptfR)             

      â I.B.2. Process Code and Space Fields
   
        â I.B.2a. Process Code Field Double-Quoted String Escapes[see "Case dqStrI"]  
        â   DQStrEsc 
          dq2Pâ†     '"{2}'                                         â ""  => "
          e2DmdPâ†   '\\{2}â‹„'                                       â \\â‹„ => \â‹„
          e1DmdPâ†   '\\{1}â‹„'                                       â \â‹„  => \r   (carriage return)
          unicodePâ† '(\\{1,2})\{\h*(\d+)(?|\h*-\h*(\d+)|())\h*\}'  â \{nnn-mmm}, \{nnn}, \\{anything else}
          dqStrEscPatsâ† dq2P e2DmdP e1DmdP unicodeP
                        dq2I e2DmdI e1DmdI unicodeIâ† â³â‰¢dqStrEscPats
          DQStrEscâ†  dqStrEscPats  â•R {
              â‹„ Caseâ† âµ.PatternNumâˆ˜âˆŠ
              â‹„ Fldâ†  âµ.(âŒ·âˆ˜Lengthsâ†‘Blockâ†“â¨âŒ·âˆ˜Offsets)
            Case dq2I:  '"'
            Case e2DmdI: 1â†“Fld 0 
            Case e1DmdI: CR '\â‹„'âŠƒâ¨isPseudo   âŠ£ CRâ†â•UCS 13 
          â Case unicodeI:  
            2=â‰¢Fld 1: 1â†“Fld 0      
              beg endâ† âŠƒâˆ˜âŒ½âˆ˜â•VFIâˆ˜FldÂ¨2 3 
            0=â‰¢end: â•UCS beg â‹„ â•UCS beg+(Ã—âˆ†)Ã—â³1+|âˆ†â†end-beg
          } 
        â I.B.2b. Process Code and Space Fields
        â   ProcCSF
        â   - Returns executable code
          dqStrPâ†   '(("[^"]*")+)'                     â "..." 
          sqStrPâ†   '((''[^'']*'')+)'                  â '...' Should this exist or are single quotes not special?
          dolPâ†     '\h*(\${1,2})\h*'                  â $ and $$ shortcuts.   
          â‹„ dolCodeVâ† fmtC boxFnC
          pctPâ†     '\h*(\%{1,2})\h*'                  â % and %% shortcuts
          â‹„ pctCodeVâ†  overC chainC
          omegaNPâ†  '[âµâ¹](\d+)'                        â â¹N, âµN        
          omega0Pâ†  'âµ_|â¹_?'                           â â¹ âµ_
          comPâ†     'â[^}â‹„]+'                          â Comments: (limited pattern)                         
          csfPatsâ† dqStrP sqStrP comP dolP pctP omegaNP omega0P 
                   dqStrI sqStrI comI dolI pctI omegaNI omega0Iâ†â³â‰¢csfPats
          omegaGâ†0
        ProcCSFâ†  WrapPrn {                            â Parens around each result!
            parensOnlyâ†âº
            codeâ† csfPats â•R {
                â‹„ Caseâ† âµ.PatternNumâˆ˜âˆŠ
                â‹„ Fldâ†  âµ.(âŒ·âˆ˜Lengthsâ†‘Blockâ†“â¨âŒ·âˆ˜Offsets)
              Case dqStrI: ' ',WrapSQ DQStrEsc 1â†“Â¯1â†“Fld 0  â DQ String: Escapes applied
              Case sqStrI: Fld 0                       â SQ String: No Escapes applied
              Case comI:   ''                          â Ignore comments...
              Case dolI:   dolCodeVâŠƒâ¨ 2=â‰¢Fld 1         â $/$$: â•FMT/BOX
              Case pctI:   pctCodeVâŠƒâ¨ 2=â‰¢Fld 1         â %,%%: OVER/CHAIN
              Case omegaNI: '(âµâŠƒâ¨â•IO+',')',â¨f1       âŠ£  omegaGâŠ¢â† âŠƒâŒ½â•VFI f1â†Fld 1              
              Case omega0I: '(âµâŠƒâ¨â•IO+',')',â¨â•omegaG  âŠ£  omegaG+â† 1   
            } âµ                                          
          parensOnly: code                             â Return a code str with no refs to âº, âµ, ...
            _Decorâ†('âº'/â¨nsOpt)âˆ˜,'{',,âˆ˜'}âµ'            â Code str decorations: âº{...}âµ
            _Trimâ† ' â‹„'âˆ˜{âµâ†“â¨-+/âˆ§\âºâˆŠâ¨âŒ½âµ}                â _Trim: Remove trailing ' â‹„'
            sfxâ†Â¯1â†‘trmâ† _Trim code                     â _sfx: last (non-trailing) char
            notSDâ† ~sfxâˆŠ'â†’â†“'                           â Does _sfx mean self-documenting code?                          
          notSD: _Decor code                           â  - NO:  Return the code
            jDCâ† chainC overCâŠƒâ¨ sfx='â†“'                â  + YES: Join doc+code via CHAIN or OVER.
            (WrapSQ âµ), jDC, _Decor Â¯1â†“trm             â         with quoted doc and trimmed code 
        }
          
      â I.B.3. Process all fields by type, set by Tok2Flds below.  
      â   ProcFlds                  
      â   - Returns at least 2 fields (Pad2Flds), as required by CHAINdef (which see).
          Pad2Fldsâ†  âŠ¢,â¨ 'â¬'â´â¨ 0âŒˆ 2-â‰¢  
          CondBoxâ† (WrapPrn boxModeC,âŠ¢)â£boxOpt         â If boxmode, put âµ in a box!
          CondSVâ†  (WrapPrn (','/â¨1=â‰¢â¤âŠ£),1â†“âŠ¢)â£boxOpt   â If boxmode, treat scalar âµ as vector for boxing
        ProcFldsâ† Pad2Flds CondBoxâˆ˜{ 
            IsCSF âµ: (IsSF âµ) ProcCSF 1â†“âµ â‹„ âµ CondSV ProcTF âµ  â IsCSF: Is it a CF or SF?  IsSF: Is it a SF?
        }Â¨

  â I.C. Tokenizing F-String to Fields (space fields [3 subtypes]; code fields; all else as text fields)
  â      Tok2Flds    
  â      - Returns: A set of fields, each as a char vec. Any strings not tagged here default to a Text Field.                                              
          sfNullPâ† '(?x) \{ (?: \h* : 0* :? \h* )? (?:â[^}]*)? \}'       
          â‹„ sfNullRâ† TagTF ''                          â {}     Null Space Field            => ('')                             
          sf1Pâ† '(?x) \{ ( \h* ) (?:â[^}]*)? \}'    
          â‹„ sf1Râ†    TagTF '\1'                        â {' '}  Constant quoted Space Field => (' ')
          sf2Pâ† '(?x) \{ \h* : ( \d+ | â¹ \d*  | âµ (?:\d+|_)? ) :? \h* (?:â[^}]*)? \}'     
          â‹„ sf2Râ†    TagSF '\1â´'''''                   â {:nn:} Numeric/âµN Space Field      => (nnâ´'') etc.                              
          cfPâ† '(?x) (?<P> (?<!\\) \{ ((?>  [^{}"â\\]+ | (?:\\.)+ | (?:"[^"]*")+ | â[^}â‹„]* | (?&P)* )+)  \} )' 
          â‹„ cfRâ†     TagCF '\2'                        â {code} Code Field                  => ([âº]{code}âµ)
          tokPVâ†  sfNullP sf1P sf2P cfP 
          tokRVâ†  sfNullR sf1R sf2R cfR
          â‹„ RemoveNullFâ†  âŠ¢(/â¨)0âˆ˜â‰ â¤â‰¢Â¨                
        Tok2Fldsâ† RemoveNullF tokPV â•R tokRV

  â I.D. Executive: Put it all together
        â‹„ AddPreambleâ† (nsOpt/'(â•NSâ¬)') ,'{','}',â¨ chainFoldC,(âˆŠâŒ½â£ (~isPseudo))
        AddPreamble ProcFlds Tok2Flds âŠ†âŠƒâµ
    }âŠ†âµ  

  ââ€¦ INTERNAL HELP DOCUMENTATION STARTS HERE â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦
  âH âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  âˆ†F  
  âH âˆ†F: Simple format string function in an APL style based on 2D text, variables and code, 
  âH     and space fields, with shortcuts for numeric formatting, titles, and more. 
  âH     Inspired by, but divergent from, F Strings in Python.
  âH â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦â€¦
  âH Syntax:  options âˆ†F f-string args
  âH      f-string:      A string containing variables, code, text and formatting  
  âH                     specifications to display a mixture of APL objects easily.
  âH      args:          O or more "arguments" that can be easily used to incorporate 
  âH                     on-the-fly values into the format string.
  âH      options:       [ [MODE=1|0|Â¯1] [ [BOX=0|1] [ [NS=0|1]  [ [EXECNS=callerNs|nsRef] ]]] | 'help' | â¬ ]
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨â†‘Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨â†‘Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨â†‘Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨â†‘Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH   options      âˆ†F Returns 
  âH > MODE=1       [IMMEDIATE] A char matrix based on the format string and subsequent values of âµ. 
  âH                (Default mode). In this mode, 2D fields are "chained" together 
  âH   MODE=0       [CODE GEN] A char vector, representing an executable dfn in string form
  âH                (which can be established via MyFmtDfnâ† â0 âˆ†F myFmtStr)
  âH   MODE=Â¯1      [PSEUDO-CODE]A char vector representing the formatting as a pseudo-code string,  
  âH                suitable for inspection, debugging, etc.
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH > BOX=0        Each field is displayed normally (and returned per MODE). (Default).
  âH   BOX=1        Each field  will be displayed in a 2D box (and returned per MODE). 
  âH                Blanks will be replaced by a center dot (Â·) in the output. 0-width fields are omitted.
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH > NS=0         Code fields have no private NS passed as âº. (Default).
  âH   NS=1         A private NS shared among all Code Fields will be passed as âº.
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH > EXECNS=callerNs  Code Fields are executed in the ns from which âˆ†F was called (0 may be used to signify it).
  âH   EXECNS=nsref     Code fields are executed in namespace <nsref>, which must be a valid namespace reference.
  âH                    This option is IGNORED if MODEâ‰ 1, since execution is left to the user (for Mode=0).
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH   âºâ‰¡'help'     An empty char vec (''). See HELP.
  âH   âºâ‰¡â¬          A shy char matrix (1 0â´' '). Right arg âµ is ignored. No formatting is done.
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH EXAMPLES
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH Example 1a:  Text Fields and Code Fields {â€¦} with simple variables.
  âH        namesâ†  â†‘'John Jones'  'Mary Smith'
  âH        addrâ†   â†‘'1214 Maiden Ln'  '24 Hersham Rd'
  âH â€¦      âˆ†F 'Name: { names }  Addr: { addr }'
  âH     Name: John Jones  Addr: 1214 Maiden Ln
  âH           Mary Smith        24 Hersham Rd 
  âH 
  âH Example 1b: Self-documenting code expressions {â€¦â†’} in Code Fields.
  âH     â Same definitions as above. 
  âH â€¦      âˆ†F '{namesâ†’}  {addrâ†’}'
  âH     namesâ†’John Jones   addrâ†’1214 Maiden Ln  
  âH           Mary Smith        24 Hersham Rd 
  âH
  âH Example 1c: Titles (using the OVER shortcut %)
  âH     â Same definitions as above. Char strings in {code} use double quotes like "this!". 
  âH â€¦      âˆ†F '{"Name" % names}  {"Address" % addr}'
  âH        Name        Address    
  âH     John Jones  1214 Maiden Ln
  âH     Mary Smith  24 Hersham Rd 
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH Example 2: Calculations and Formatting ($, short for â•FMT) in Code Fields.
  âH       câ†  100 20 12 23 Â¯2
  âH       Fâ†  32+1.8âˆ˜Ã—
  âH     â 2a: Format specification as an argument âµ1, i.e. (1+â•IO)âŠƒâµ. (Degree sign (Â°): â•UCS 176)
  âH â€¦     âˆ†F '{ âµ1 $ c }C = { âµ1 $ F c }F' 'I3,âŠ‚Â°âŠƒ'   â Result is a 5-row 15-col char matrix.
  âH  100Â°C =  212Â°F
  âH   20Â°      68Â°              
  âH   12Â°      54Â°              
  âH   23Â°      73Â°              
  âH   Â¯2Â°      28Â°  
  âH
  âH     â 2b: Format specification hard-wired in Code Field. 
  âH     â     Note alternative way to enter 'Â°' as unicode 176 (decimal).
  âH â€¦     âˆ†F '{ "I3,âŠ‚Â°âŠƒ" $ c }C = { "F5.1,âŠ‚\{176}âŠƒ" $ (32+1.8âˆ˜Ã—) c }F'  
  âH  100Â°C = 212.0Â°F
  âH   20Â°     68.0Â° 
  âH   12Â°     53.6Â° 
  âH   23Â°     73.4Â° 
  âH   Â¯2Â°     28.4Â° 
  âH 
  âH     â 2c: Variant on (2b) with a header for each Code field using the % (OVER) shortcut.
  âH â€¦     âˆ†F'{"Celsius" % "I3,âŠ‚Â°âŠƒ" $ c }  { "Fahren." % "F5.1,âŠ‚Â°âŠƒ" $ (32+1.8âˆ˜Ã—) c }'
  âH  Celsius  Fahren.
  âH   100Â°    212.0Â° 
  âH    20Â°     68.0Â° 
  âH    12Â°     53.6Â° 
  âH    23Â°     73.4Â° 
  âH    Â¯2Â°     28.4Â° 
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH Example 3: BOX display option (1=âŠƒâŒ½âº)
  âH     â Displays each field in its own "box" (ignoring null (0-width) fields)
  âH     â Field:  1..â¬ â¬  2 3â€¦  4..   â¬   5 6â€¦.
  âH â€¦     1 1 âˆ†F 'one{}{}{ }two {"two"}{:0}{ }three'  
  âH   â”Œâ†’â”€â”€â”â”Œâ†’â”â”Œâ†’â”€â”€â”€â”â”Œâ†’â”€â”€â”â”Œâ†’â”â”Œâ†’â”€â”€â”€â”€â”
  âH   â”‚oneâ”‚â”‚ â”‚â”‚two â”‚â”‚twoâ”‚â”‚ â”‚â”‚threeâ”‚
  âH   â””â”€â”€â”€â”˜â””â”€â”˜â””â”€â”€â”€â”€â”˜â””â”€â”€â”€â”˜â””â”€â”˜â””â”€â”€â”€â”€â”€â”˜
  âH     â Without BOX option.
  âH â€¦     âˆ†F 'one{}{}{ }two {"two"}{:0}{ }three'   â Or: 1 0 âˆ†F â€¦
  âH   one two two three
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH HELP
  âH Â¨Â¨Â¨Â¨
  âH For help, enter  
  âH   âˆ†Fâ¨'help'   OR  'help' âˆ†F ''  
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH A. The âˆ†F Format String (â¹0)
  âH Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯Â¯
  âH The f-string is a character vector defining 0 or more 2-D (char matrix) "fields," 
  âH which are executed like separate statements-- left to right-- and assembled into a single matrix 
  âH (with fields top-aligned). Its contents are in "shortcut" variable â¹0.
  âH
  âH There are 3 types of fields generated: 
  âH    1. Code Fields, 2. Space Fields, and 3. Text Fields.
  âH
  âH A1. Code Fields: 
  âH        radiiâ† 12 2.3 19
  âH â€¦      âˆ†F ' { Area_Cirâ†{â—‹âµÃ—âµ} â‹„ "F8.2" $ radii,â¤Â¯1âŠ£ (Area_Cir radii) }' 
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH    Code Fields are dfns and may contain any dfn code, including error handling. 
  âH    Internally, each code field is executed right-to-left, as in APL.
  âH    Each Code field has implicit right arguments, namely everything passed to âˆ†F as âµ when executed.
  âH 
  âH    Special Variables â¹0,â¹, etc., used in Code Fields*
  âH    Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨  * Alias âµ0, âµ_, etc. See also usage in Space Fields.
  âH       â¹0, â¹1, â€¦ âµN, denote the scalars in the right arg (âµ) passed to âˆ†F. 
  âH       â¹ is the glyph â•UCS 9081.
  âH       â¹0: (0âŠƒâµ) the format string itself (â•IO=0).  
  âH       â¹1: (1âŠƒâµ) the first scalar after the format string. 
  âH       â¹N: (NâŠƒâµ) the Nth scalar after the format string, N one or more digits.
  âH       â¹:  [â¹ with no digits immed following]
  âH           selects the "next" scalar to the right, starting AFTER the format string with â¹1.
  âH        âˆ˜  The counter for â¹ is incremented by 1 just before each use. 
  âH        âˆ˜  The counter for â¹ is set after each use of â¹N from left to right in Code Fields in the format string:  
  âH           * If  â¹N is used in a Code Field, the next â¹ is â¹N+1;
  âH           * If more than one  expression â¹N, â¹P, â¹Q appears in any Code Field, 
  âH             the one just before the â¹ on the left determines its next value (here â¹Q+1).
  âH        âˆ˜  NB: the initial value of â¹ is â¹1, never â¹0. (â¹0 may only be referenced explicitly).
  âH        âˆ˜  â¹'s index is set at "compile" time, scanning LEFT to RIGHT (not RIGHT to LEFT as for stmt execution):
  âH           Thus 
  âH              âˆ†F '{â¹ â¹ â¹} and {â¹ â¹ â¹}' 1 2 'three' 4 'five' 6 
  âH           returns 
  âH              1 2 three and 4 five 6
  âH        âˆ˜  There are easy to type alternatives to using the glyph 'â¹' :
  âH           IN PLACE OF            USE
  âH           â¹0, â¹1, â€¦ â¹N         âµ0, âµ1, â€¦ âµN     e.g. â¹5Ã—â¹6 â‰¡ âµ5Ã—âµ6
  âH           bare â¹                 âµ_                 e.g. â¹+1   â‰¡ âµ_+1
  âH        âµ  What about âµ (without any numeric suffix or _)?
  âH           âµ by itself is not special, indicating the entire right arg to âˆ†F (when executed);
  âH           it consists of the scalars â¹0 â¹1 â€¦ â¹N.
  âH 
  âH    {ccc} Code Field Syntax and Quoted Strings
  âH    Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨  
  âH     ccc  any dfn code, including multiple stmts, guards, and error guards.
  âH        âˆ˜ A left brace '{' begins a code field, which is terminated by a balancing right brace '}'.
  âH        âˆ˜ Code ccc is executed and the result is formatted via â•FMT.
  âH        âˆ˜ \{ and \}, i.e. braces escaped with backslash (\), do NOT start a code field. 
  âH          They are simple '{' and '}'.
  âH        âˆ˜ To enter quoted strings in Code Fields, use double quotes "like these":
  âH          - {â•NC "fred"} is easier than {â•NC ''fred''}
  âH          - In a code field, there are a few escape sequences within double-quoted strings ONLY. 
  âH            Outside of these cases, backslashes (\) are, as in std APL, not special.
  âH               \â‹„         indicates a carriage return (â•UCS 13). It is left as is if MODE=Â¯1.
  âH               \\â‹„        indicates chars '\â‹„'
  âH               \{nnn}     indicates* (â•UCS nnn), where nnn consists of 1 or more digits 
  âH                                     (*) W/o a 2nd preceding backslash; leading/trailing spaces ok. 
  âH               \{nnn-ppp} indicates* unicode chars from nnn to ppp
  âH                          inclusive, where nnn,ppp are 1 or more digits  
  âH                                     (*) W/o a 2nd preceding backslash; leading/trailing spaces ok. 
  âH               \\{nnn}  OR  \\{nnn-mmm}
  âH                     indicates literal string  \{nnn} OR \{nnn-mmm}, i.e. APL text with the extra \ removed.
  âH               Any other variant of \{â€¦} or backslash within strings is kept as ordinary tet:               
  âH                           "\{123+â³5}" ==> "\{123+â³5}"   (unchanged, including \);
  âH                           "abc\def"   ==> "abc\def"     (unchanged, including \).
  âH             Examples
  âH             Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH â€¦                âˆ†F '"{"\{97-109}â€¦\{57-48}"}"' 
  âH              "abcdefghijklmâ€¦9876543210"
  âH                â In DQ strings, "\â‹„" is the same as "\{13}".
  âH â€¦                âˆ†F '{"Dogs\â‹„Cats"} same as {"Dogs\{13}Cats"}'
  âH              Dogs same as Dogs
  âH              Cats         Cats 
  âH        âˆ˜ To include a double quote (") within a double-quoted string, double it the APL way:
  âH             "abc""def""ghi"  ==>   abc"def"ghi
  âH        In a code field (outside strings)
  âH        âˆ˜ $ is a special symbol for â•FMT to allow easy formatting (using the dyadic variant):
  âH             {"F8.2" $ MyCodeâ€¦}       â Same as {"F8.2" â•FMT MyCodeâ€¦}
  âH        âˆ˜ $$ (BOX) is a special symbol for the display function (see the DFNS ws), which 
  âH          formats objects in a box:
  âH             { $$ MyCodeâ€¦} 
  âH        âˆ˜ $$ and Dyadic $ used together may be useful:
  âH             { $$ "F8.2" $ MyCode}    â $ Formats MyCode then $$ puts in a box.
  âH        âˆ˜ % (OVER) is a special symbol for placing one â•FMT-able object "over" another, each centered/padded.
  âH          - Each object is converted to a char. array (if not already), padding if necessary, 
  âH            then the left (âº) is catenated OVER the right (âµ).
  âH          - The % (OVER) option is useful for titles or for building hierarchical displays without
  âH            doing all the gluing yourself.
  âH          - See the example(s) above.
  âH        âˆ˜ %% (CHAIN) is a special symbol for placing one â•FMT-able object to the left of another.
  âH          The objects are not centered, but simply catenated (CHAINed) together.
  âH          CHAIN is also used to build the âˆ†F formatted object from all the fields (see MODE=Â¯1). 
  âH        âˆ˜ A Code Field may include limited comments (even though on a single line), 
  âH          beginning with a 'â' and terminated just before the next 'â‹„' or '}' on the same line.
  âH          Braces {} (escaped or not), statement ends (â‹„) and (double) quotes are 
  âH          not allowed in Code Field comments.
  âH     Self-Documenting Code Fields
  âH       a. HORIZONTAL â†’
  âH       {ccc â†’} A Self-documenting Horizontal Code Field
  âH          A Code Field with a trailing right arrow (â†’) will generate two fields:
  âH          âˆ˜ the code itself in literal form (incl. spaces and [limited] comments), 
  âH            followed by its evaluated value:
  âH              âˆ†F'A: {âªâ³âµ1 â†’ },  B: {âªâµ2+â³âµ1 â†’ }' 2 3
  âH            A: âªâ³âµ1 â†’ 0,  B: âªâµ2+â³âµ1 â†’ 3
  âH                      1                4
  âH       b. VERTICAL â†“ (EXPERIMENTAL OPTION)
  âH       {ccc â†‘} A Self-documenting Vertical Code Field
  âH          A Code Field with a trailing down arrow (â†“) will generate a field withâ€¦
  âH          âˆ˜ the code itself in literal form (incl. spaces and [limited] comments), 
  âH            OVER its evaluated value (as if the %% shortcut was used):
  âH               Nameâ†â†‘'John' 'Mary'
  âH               Ageâ† âª 34     27
  âH               âˆ†F'{Nameâ†“} {Ageâ†“}'
  âH            Nameâ†“ Ageâ†“
  âH            John   34 
  âH            Mary   27 
  âH        âˆ˜ Extra blanks and comments are allowed within a Self-documenting Code Field and
  âH          will appear in the output.
  âH â€¦           âˆ†F'â•IO={â•IO}. {âªâ³âµ1 â†’ â SIMPLE }  {âªâµ2+â³âµ1 â†’ â FANCY }' 2 3
  âH          â•IO=0. âªâ³âµ1 â†’ â SIMPLE 0  âªâµ2+â³âµ1 â†’ â FANCY 3
  âH                                 1                    4
  âH
  âH A2. Space Fields: 
  âH     {  }  OR { :10: } OR { :â¹9: }
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH    Space fields look like Code Fields, except they contain  
  âH         âˆ˜ only 0 or more spaces, or
  âH         âˆ˜ :nn:, i.e. a colon, 0 or more digits, followed by a colon
  âH         âˆ˜ :â¹[N]: or :âµ[N_]:, i.e. a colon, â¹ or âµ, followed by digits/underscore, followed by a colon.
  âH    or all together:
  âH         âˆ˜ { [sss] | :[nn]: | :[â¹âµ][N_]: } 
  âH     sss      0 or more spaces               inserts spaces indicated
  âH     nn       zero or more digits            inserts nn spaces. 
  âH     â¹N etc.  A single special variable      inserts â¹N at execution time.
  âH              â¹1, â¹9, â¹, âµ_, âµ1, âµ9, etc.    
  âH
  âH     For Numeric or Special Variable Space Fields
  âH     âˆ˜ The colon prefix is required;  the colon suffix is optional.
  âH     âˆ˜ An ill-formed Space Field will be treated as a Code Field, likely triggering an error.
  âH     âˆ˜ Only one special variable is allowed here (i.e. â¹5 or â¹, but not â¹4+â¹5, etc.).
  âH       If you want to do a calculation, simply use a code field: {" "â´â¨â¹4+â¹5}.
  âH
  âH     A 0-width Space Field {} is handy as a separator between multiline Text Fields (q.v.).
  âH
  âH A3. Text Fields:  
  âH     âˆ†F 'Any\â‹„multiline\â‹„text{}Next field!' 
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH    Everything else is a Text Field. Variable names, etc., in text field are just text.
  âH    âˆ˜ Text fields may contain newlines entered as \â‹„. Simple â‹„ is not special.
  âH    âˆ˜ To show literal \â‹„, enter \\â‹„.  
  âH    âˆ˜ To show { or } as text, enter \{ or \}. 
  âH    âˆ˜ In all other cases, simple \ is not special: +\ is simply +\, \d is simply \d.
  âH    âˆ˜ You can use {} to separate Text Fields.
  âH      {} is a 0-width Space Field (see 2. Space Fields above).
  âH      EXAMPLE: 
  âH        Compare these two cases, the first with {} separating 2 multiline Text Fields:
  âH â€¦         âˆ†F 'One\â‹„two{}-Three\â‹„-four'  vs    âˆ†F 'One\â‹„two-Three\â‹„-four' 
  âH        One-Three                           One
  âH        two-four                            two-Three
  âH                                            -four
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH Differences from Python
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH    âˆ†F APL-style                             Python
  âH    Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨                             Â¨Â¨Â¨Â¨Â¨Â¨    
  âH    â Build fields all at once L to R        # Build annotations row by row
  âH      RGBâ†  123 145 255                      R = 123 ; G = 145 ; B = 255
  âH â€¦    âˆ†F 'R:\â‹„G:\â‹„B:{ }{âªRGB}'               print((f'R: {R}\nG: {G}\nB: {B}'))
  âH    R: 123                                   R: 123
  âH    G: 145                                   G: 145
  âH    B: 255                                   B: 255
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨                            Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH    â Use APL for base conversions         # Base conversions are built in
  âH â€¦    âˆ†F '"{"01"[2âŠ¥â£Â¯1âŠ¢âµ1]}"' 7              f'{7:b}'
  âH    "111"                                    '111'
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨                            Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH    â Formatting Floats old-fashioned?     # Similar approach, different conventions
  âH      xâ† 20.123                              x = 20.123
  âH â€¦    âˆ†F'{"F8.5"$x}' â User calcs width      print(f'{x:0<8}')   # User calcs width
  âH    20.12300                                 20.12300
  âH â€¦    âˆ†F '{5â•x}'     â APL calcs width       print(f'{x:.5f}')   # Python calcs width
  âH    20.12300                                 20.12300
  âH
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH B. âˆ†F Options:  âº[0] (default âº[0]=1)  MODE Option
  âH                 âº[1] (default âº[1]=0)  BOX Option
  âH                 âº=â¬                    âˆ†F FORMATTING SKIPPED
  âH                 âº='help'               Show HELP information
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH B1. âˆ†F has three modes[*], determined by âº[0]= 1, 0, or Â¯1.
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨       * Ignored if âº=â¬ or âº='help'
  âH âº[0]  MODE Option
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH [1]   âˆ†F IMMEDIATE MODE
  âH âº[0]=1     1 âˆ†F fs âµ1 âµ2 â€¦ âµN          â âº=1 is the default
  âH     âˆ˜ Executes the format string fs, implicitly passing any scalars âµ1â€¦âµN to 
  âH       the right as arguments.
  âH     âˆ˜ Note: Variables and settings seen are those of the CALLING environment 
  âH       where âˆ†F is executed.
  âH     âˆ˜ Returns: a char matrix consisting of the fields built per the format and scalars passed.
  âH
  âH [0]   âˆ†F CODE GENERATION MODE
  âH âº[0]=0     0 âˆ†F fs
  âH     âˆ˜ Generates a code string CS that can be executed (without repeatedly calling âˆ†F 
  âH       to reparse fs) as 
  âH         (âCS) âµ1 âµ2 â€¦ âµN   or     Dfnâ†âC                â (âCS) or Dfn is an executable dfnâ€¦
  âH                                   Dfn âµ1 âµ2 â€¦ âµN
  âH       where the args âµ1â€¦âµn will be combined at EXECUTION time with fs as (fs,â¥âŠ†âµ1â€¦âµN), 
  âH       where fs, the format string text originally passed to âˆ†F, is automatically 
  âH       assigned to â¹0, as expected.
  âH     âˆ˜ Note: Variable and fn names in Code Fields are resolved in the calling environment 
  âH         when (âC) is executed; a different namespace "ns" may be specified via (nsâC), 
  âH         a standard feature of execute (â).
  âH     âˆ˜ Returns: a char vector representing an executable dfn with results identical to 
  âH         1 âˆ†F fs â¹1 â¹2 â€¦ â¹N
  âH
  âH [Â¯1]  âˆ†F PSEUDOCODE MODE
  âH âº[0]=Â¯1    Â¯1 âˆ†F fs
  âH     âˆ˜ Generates a pseudo-executable P, which is identical to X, except
  âH       - the internally used catenation function is abbreviated to the symbolic function name â™CHAIN,
  âH       - newline escapes \â‹„ are maintained as \â‹„, suppressing
  âH         multiline output, so the pseudocode can be easily inspected.
  âH     âˆ˜ Returns: a char vector of pseudocode.
  âH
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH B2. âˆ†F has a BOX Option that puts each field into a display box
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH âº[1]  BOX Option
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH âº[1]=0 DEFAULT (NOBOX) Setting
  âH     âˆ˜ Output displayed normally, without extra boxing.
  âH 
  âH âº[1]=1 BOX Setting
  âH     âˆ˜ Output is displayed with each field shown within its own box, 
  âH       whether a text, space, or code field.
  âH     âˆ˜ Any null fields generated (0-width) are suppressed, i.e. 
  âH       not shown at all in the output.
  âH     âˆ˜ BOX mode is useful for verifying the expected output format
  âH       is achieved for each input field. 
  âH
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨ 
  âH B3. Simple Options for âº
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH âº:   âˆ†F FORMATTING SUPPRESSED
  âH âºâ‰¡â¬      â¬ âˆ†F fs
  âH      Immediately return a shy result of (1 0â´' '), ignoring right argument.
  âH      Useful when a format stmt âˆ†F is to be ignored (esp. useful in a Tradfn).
  âH            VOLTAGE CURRENT FREQâ† Initialize â¬
  âH            :FOR STEP :IN 1+â³ITERATIONS  â â•IO=0
  âH               VOLTAGE CURRENT FREQâ† CalcNextStep VOLTAGE CURRENT FREQ 
  âH             â Show results on STEP 100 200 etc.
  âH â€¦             (1/â¨0=100|STEP) âˆ†F '[{STEP}] Key Vars: {VOLTAGEâ†’}V, {CURRENTâ†’}A, {FREQâ†’}Hz.'
  âH            :ENDFOR
  âH         [100] Key Vars: VOLTAGEâ†’240V, CURRENTâ†’20A, FREQâ†’50Hz.
  âH -----------------------------
  âH âº:   Show HELP information
  âH â€¦        'help' âˆ†F ''  OR âˆ†Fâ¨'help'
  âH      Show this HELP information in an â•ED editor session, then return ''.
  âH 
  âH PERFORMANCE
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH As a prototype, âˆ†F is relatively slow compared to building formatted objects "by hand"
  âH but serviceable enough. Where important, e.g. in loops, you may wish to
  âH scan (compile) the format string before the loop and then run the resulting dfn (here: Fmt1):
  âH
  âH EXAMPLE OF CODE GEN MODE (0 âˆ†F â€¦)
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH      â In a TRADFN                      â In a DFN
  âH â€¦      Fmt1â† â0 âˆ†F '{â€¦}â€¦{}â€¦{}'            Fmt1â† â0 âˆ†F '{â€¦}â€¦{}â€¦{}' 
  âH        :FOR i :IN â³Whatever               _â†{ 0=âµ: _â†âº
  âH             â€¦ do stuff â€¦                    â€¦ do stuff â€¦
  âH             Fmt1 arg1 arg2 â€¦                â•â†Fmt1 arg1 arg2 â‹„ âº âˆ‡ âµ-1
  âH        :ENDFOR                            }â¨ Whatever
  âH
  âH Tentative Relative âˆ†F Timings* of Immediate Mode vs Code Gen (Compiled) Mode
  âH Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨Â¨
  âH                                 COMPILE â†’ CODE STR â†’ DFN â†’ RUN    Rel. Timings
  âH      âˆ†F fmt âµ1 âµ2 â€¦    100%    |<==========================>|    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  âH CSâ†  0 âˆ†F fmt           85.7%  |<==============>|                â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  âH DFNâ† âCS                 4.3%                   |<=>|            â•
  âH DFN âµ1 âµ2 â€¦             10.0%                       |<=====>|    â•â•â•
  âH -----------
  âH [*] Test had six fields, exhibiting a range of field types. 
  âH     âˆ†F strings are typically small in size and number.
  âH
}