∆FIX←{   
  ⍺←'' ⋄   ⎕IO← 0   
  HERE← ⊃⎕RSI 
⍝ Options: See HelpInfo for documentation
  2≤|≡⍺: 11 ⎕SIGNAL⍨'∆FIX: Options (⍺) must be a single char vector or scalar. Use option "?" for more info.'
  FIX VERBOSE DEBUG PATH HELP←'fix' 'verbose' 'debug' 'path' '?' (1⍨∊⍷)¨ ⊂⎕C ⍺  
  VERBOSE∨← DEBUG 
⍝ SQMULTI_ALLOW=0:  Do not allow single-quote strings to extend over multiple lines.
⍝ SQMULTI_ALLOW=1:  As for double-quoted strings, allow single-quote strings to extend over multiple lines.
  SQMULTI_ALLOW←1
  0/⍨~VERBOSE:: ⎕SIGNAL/⎕DMX.(EM EN)

⍝ Help...
  HelpInfo←{ H←⍬
      H,←⊂'  ∆FIX: Preprocess and optionally ⎕FIX code lines in a file or a vector of code lines.'
      H,←⊂'  ∆FIX SYNTAX: [ option_string] ∆FIX [file-spec | vector-of-code-lines]'
      H,←⊂'    option_string (a single string with one or more of these words with case ignored):'
      H,←⊂'      FIX      Run 2 ⎕FIX on the output. Otherwise, return the output as a vector of code lines.'
      H,←⊂'      VERBOSE  Show some diagnostic information as ∆FIX preprocesses.'
      H,←⊂'      DEBUG    Set VERBOSE to 1 and start debugging.'
      H,←⊂'      PATH     Find initial file (file-id) in search path, if not in current directory or fully specified.'
      H,←⊂'      ?        Display this "help" information and shyly return ⍬.'
      H,←⊂'  Note: For :INCLUDEd files, <file-spec> searches current filepath, this dir (''.''), FSPATH, WSPATH.'
      H,←⊂'  Otherwise, specify'
      H,←⊂'      ∘ without angled brackets <>, i.e. file-spec, or'
      H,←⊂'      ∘ within quotes, ''file-spec'' or "filespec"'
      H,←⊂'Directives...'
      H,←⊂'  :INCLUDE [ file-spec | "file-spec" | <file-spec> ]'
      H,←⊂'      ∘ file-spec OR "file-spec"'
      H,←⊂'        Find the file within the active :INCLUDE directory (same as filename on cmd line or ".")'
      H,←⊂'      ∘ <file-spec>'
      H,←⊂'        Find the file in WSPATH (Dyalog) or FSPATH (PMS), if not found as if "file-spec" above.'  
      H,←⊂'  :DEF[L][E|X][Q] name[←]value-string'
      H,←⊂'      ∘ L  literal'
      H,←⊂'        Default is to replace name with value-string in parentheses.'
      H,←⊂'        L suppresses the parentheses.'
      H,←⊂'      ∘ E execute value-string when defined and store result as the replacement string.'
      H,←⊂'      ∘ R (or ER) execute value-string each time when replaced.'
      H,←⊂'      ∘ Q place result from :DEF[L][E] inside single quotes (expanding internal quotes).'
      H,←⊂'  :DECLARE name←value'
      H,←⊂'  :DECL name←value'
      H,←⊂'       value: Dyalog APL "serial" value, possibly across multiple lines.'
      H,←⊂'  :UNDEF name'
      H,←⊂'       Remove any special value for name.'
      ⍬⊣⎕ED 'H'
  }
⍝ Include:
⍝   If ⍵ is a filename (char vector), process the file contents.
⍝   Otherwise, process the lines.
⍝   Inserts pseudo-macro line:  ::FILE fname
⍝ Returns a vector of lines (char vectors)
  Include←{
      INCL_ONCE←⍬
      CUR_INCLUDE_DIR←⊂∊⎕SH 'pwd'              ⍝ No terminating '/'
      CUR_FILES←⊂'[TERM]'
      LAST_INCLUDED_FI← '[NONE]'
      ScanFi←{
          fn srch←⍵ 
          fn←srch{
            ⍺: (⊃⌽CUR_INCLUDE_DIR) NGetNameInPath ⍵ ⋄ ⍵
          }fn
          CUR_FILES,← ⊂fn
          CUR_INCLUDE_DIR,←⊂{0=≢⍵: ⊃⌽CUR_INCLUDE_DIR ⋄ ⍵}¯1↓⊃⎕NPARTS fn    ⍝ No terminating '/'
        22::  22 ⎕SIGNAL⍨ 'File "',fn,'" not found in current directory.'  
          ⍺ ScanLn ⊆⊃⎕NGET fn 1  
      }
      ScanLn←{ 
          lns←⍺
          0=≢⍵: lns ⊣ CUR_FILES↓⍨← ¯1 ⊣ CUR_INCLUDE_DIR↓⍨← ¯1 ⊣ LAST_INCLUDED_FI⊢←⊃⌽CUR_FILES
          w0←⊃⍵
        ⍝ ":INCLUDE file_spec" seen?
          ×≢fnVV← includeP ⎕S '\1'⊣w0: { 
              srch← 1↑⊃fnVV ⋄ fn← 1↓⊃fnVV
              srch (~∊) SQ DQ '<': 11 ⎕SIGNAL⍨'∆FIX FORMAT ERROR: ',w0
              srch←'<'=srch
              (⊂fn)∊INCL_ONCE: (lns,VERBOSE/⊂'⍝ [ONCE] ',w0) ScanLn 1↓⍵
              (lns, ('⍝ ',w0,' → ',LAST_INCLUDED_FI) ('::FILE ',DoQuotes fn)) ScanLn (⍬ ScanFi fn srch),1↓⍵  
          }⍵
        ⍝ ":PRAGMA ONCE" seen?
          ×≢pragmaP  ⎕S 0⊣w0: (lns,⊂'⍝ ',w0) ScanLn 1↓⍵  ⊣ INCL_ONCE,←⊂⊃⌽CUR_FILES 
          (lns,⊂w0) ScanLn 1↓⍵
      }
    ⍝ Is ⍵ a simple filename? 
    ⍝ If so, include it (ScanFi)...
    ⍝ Pass on to next phase the name of the file via "::FILE name"
    ⍝ If PATH is 1, will search the PATH (see NGetNameInPath)
      1≥|≡⍵: (⊂'::FILE ',DoQuotes ⍵) ScanFi ⍵ PATH
    ⍝ If not, scan line by line
      ⍬ ScanLn ⍵
  }  
⍝ :INCLUDE [ file-spec | "file-spec" | <file-spec> ]
⍝            [1a]        [1a]          [2]
⍝ [1a/b]: file must be found in current directory or directory of "outer" included file.
⍝ [1a]:   file spec may not contain blanks (see 1a and 2).  Either single or double quotes may be used.
⍝ [2]:    file may be found in search path specified by FSPATH (PMS) or WSPATH (Dyalog)
  includeP← '(?ix) ^\h* :include\h+(?| (''[^''\n]+)'' | ("[^"\n]+)" | (<[^\h\n]+)> | ([^\h\n]+) )' 
⍝ :PRAGMA ONCE or :ONCE
  pragmaP←  '(?i)^\h*:(?:pragma\h+)?once\b'
 
⍝ CONSTANTS 
  SQ DQ LP RP←'''"()' 
  CR NL←⎕UCS 13 10 
  DQ2←DQ,DQ
  QSEP←SQ,' ',SQ       ⍝ QSEP: Separates Two Quote Strings 
  OPTS←('UCP' 1)('Mode' 'M')('EOL' 'LF')('IC' 1)

⍝ Utility Fns 
⍝ Fld: Return value of numbered field of ⎕R namespace or '', if it is undefined.
  Fld← { fO fB fL←⍺.(Offsets Block Lengths) ⋄ 0≠0(≢fO)⍸⍵: '' ⋄ ¯1=wO←⍵⌷fO: ¯1 ⋄ (⍵⌷fL)↑wO↓fB }
  AddSQs←     { SQ,SQ,⍨∊(⊂QSEP)@(NL∘=)⊢⍵ }            ⍝ Add single quotes to each quoted string...
  DQ2SQ←      { {⍵/⍨DQ2(~⍷)⍵}(⍵/⍨1+SQ=⍵) }            ⍝ Internal double quotes to single quotes 
  CondParens← { ⍺: DoPars ⍵ ⋄ ⍵ }
  CondQuotes← { ⍺: DoQuotes ⍵ ⋄ ⍵ }
  CondEval←   HERE.{ 0:: '' ⋄ ⍺: ⍕ ⍎⍵ ⋄ ⍵ }
  DoPars←     LP∘,,∘RP
  DoSpaces←   ' '∘,,∘' '
  DoQuotes←   (SQ∘,,∘SQ)(⊢⊢⍤/⍨1+SQ∘=)
  DLB←        {⍵↓⍨ +/∧\ ⍵=' '}
  DTB←        {⍵↓⍨-+/∧\⌽⍵=' '}    
  HandleNL←   { 2≤⍴⍴⍵: ∊∇¨(⎕FMT ⍵),NL  ⋄ '\\⋄' ⎕R '\n' ⊣⍵ }
  Strip1LR←   1↓¯1↓⊢
⍝ Strip trailing blanks from lines of multiline strings...
  StripTB←    { NL(~∊)⍵: ⍵ ⋄ ' *\n'  ⎕R  '\n'  ⍠OPTS ⊢⍵ } 

⍝ Find a file in the search path and read it in!
⍝      ⍺: An obligatory directory to add at the START of the search path...
  NGetNameInPath←{ 
      fsp←2 ⎕NQ'.' 'GetEnvironment' 'FSPATH'   ⍝ PMS-specific
      wsp←2 ⎕NQ'.' 'GetEnvironment' 'WSPATH'
      dirs←∪':'(≠⊆⊢)⍺,':',fsp,':',wsp
      fis←dirs,¨⊂'/',⍵       ⍝ Add terminating '/' here ONLY...
      bad←0=≢fnd←fis/⍨∊⎕NEXISTS¨fis
      VERBOSE∧bad: 22 ⎕SIGNAL⍨'File "',⍵,' not found in search path:',CR,'  ',∊⎕SH 'pwd'
      bad:         22 ⎕SIGNAL⍨'File "',⍵,' not found in search path!'
      ⊃fnd
  }
⍝ Regexp Alignment Fns 
⍝ AlignLeft: No Leading Blanks...
  AlignLeft←  '\n *' ⎕R '\n' ⍠OPTS
⍝ AlignMarg: In a multiline string, 
⍝            - Ignore an initial bare line (one followed by zero or more blanks),
⍝              but respect a non-bare line.
⍝            - Each line after initial line are aligned to the first such line.
⍝            - Final bare newline is NOT ignored.
⍝ Example:
⍝ ⍝   ↓←←←← left margin
⍝     a←"
⍝       one
⍝       two
⍝          three
⍝       "  ⍝ done
⍝     ↑0 ∆FIX 'a←"' '  one'  '  two'  '   three' '"  ⍝ done'
⍝   a←('one' 'two' '   three' '')  ⍝ done
⍝   ┌───┬───┬────────┬┐
⍝   │one│two│   three││
⍝   └───┴───┴────────┴┘

  AlignMarg← {
    isFirst margin skipNL1← 1 0 0
    ⍝ Initial bare newline is ignored...
    ⍝ Set left margin from first "full" line and align following with that.
      '\A(?=\n)' '\n( *)' ⎕R {
          0=⍵.PatternNum: '' ⊣ skipNL1⊢←1                    ⍝ We skip newline at <isFirst>
          nsp← ≢⍵ Fld 1
          isFirst: skipNL1↓NL ⊣ isFirst margin⊢← 0 nsp       ⍝ Set margin 
          NL,' '⍴⍨0⌈margin-⍨nsp                              ⍝ Align with margin         
      }⍠OPTS ⊢ ⍵ 
  }

⍝ Dictionary...
  ∆DICT←{ 
    ⍝ EXTERN: HERE
      K V←⍵ ⋄ M←(≢K)⍴0
    ⍝ Get: Returns value in whatever type was stored
      NNULL←,⎕NULL     ⍝ See Get 
      pHERE←⍕HERE
    ⍝ Get:   [⍺: default] ∇ key
    ⍝    ⎕NULL is a valid left arg. ,⎕NULL means "no left arg".
    ⍝    Default for key is <key>, unless ⍺ is specified.
      Get←{ 
          HERE←⍎pHERE
          ⍺←  NNULL
          k1← 1 ⎕C⍣('⎕'=⍬⍴⍵)⊢⍵ 
          p←  K⍳⊂k1  
          p=≢K: (⍺≡NNULL)⊃ ⍺ ⍵ 
          ~×p⊃M: p⊃V  
          (2=p⊃M){ SQ←'''' ⋄ 0:: '(∘∘ERR∘∘)' ⋄  {SQ,SQ,⍨(⊢⊢⍤/⍨1+SQ∘=) ⍵}⍣⍺⊣ ⍕HERE⍎⍵ } p⊃V 
      }
    ⍝ Set: Does NOT convert numeric values to string s
    ⍝      Set key value [is_macro=0]
      Set←{ 
          k1 v1 m1←3⍴⍵,0
          k1←1 ⎕C⍣('⎕'=⍬⍴k1)⊢k1 
          p←K⍳⊂k1
          p=≢K: v1⊣ K V M ,←⊂¨ k1 v1 m1      
          (p⊃M)←m1 ⋄ ⊢(p⊃V)←v1      
      }
      Del←{
          k1←1 ⎕C⍣('⎕'=⍬⍴k1)⊢k1 
          p←K⍳⊂k1
          p=≢K: ⍵
          q←p≠⍳≢K 
          K V M /⍨←⊂ q
          ⍵
      }   
      ⎕NS  'K' 'V' 'M'  'Get' 'Set' 'Del' 'NNULL'  'pHERE' 
  }
⍝ GenBracePat '{}' etc.
⍝ Matches recursive balanced left and right "braces" passed as ⍵[0] and ⍵[1].
  GenBracePat←{
        ⎕IO←0 ⋄ ⍺←⎕A[,⍉(≢⎕A)⊥⍣¯1⊢ ⎕UCS ⍵] ⋄ Nm←⍺  ⍝ ⍺: defaults to a generated unique name based on ⍵
        Lb Rb←⍵,⍨¨⊂'\\'                     
        pM←'(?: (?J) (?<Nm> Lb  (?> [^LbRb''"⍝]+ | ⍝\N* | (?: "[^"]*")+  | (?:''[^'']*'')+ | (?&Nm)* )+ Rb))'~' '
        'Nm' 'Lb' 'Rb'⎕R Nm Lb Rb⊣pM
  }  
⍝ SQ strings: 
  sqP←        1⊃ '(''[^''\n]*'')+' '(''[^'']*'')+'         
  dqP←       '("[^"]*")+'              ⍝ DQ strings: multi-line quotes allowed.
⍝ qtErrP: For a bad quote, match (and report) only to end of current line, not end of multi-line object...
  qtErrP←    '[''"][^''"\n]*$'    
  comP←      '⍝[^\n]*$'
  numP←      '¯?[\d\.][\d\.EeJj¯]*'    ⍝ Permissive; APL to handle bad numbers. 
  nlP←       '\n'
  miscP←     '[^''"⍝\n]+'
  sinkP←     '((?:^|[[{(⋄:;\n])\h*)←' 
  tempP←     '⎕T\b'
  _w←        '[\w∆⍙]'
  _w0←       '[⎕\w∆⍙](?<![\d¯])'
  _wordP←     _w0,_w,'*(?:\.',_w0,_w,'*)*'
  wordP←      DoPars _wordP
  quotLftP←   '(?|(?<='')|',wordP,')\h*→'
  quotRgtP←   '`\h*(?|(?='')|',wordP ,')'
  quotRgtErrP←'`'    
⍝ :DEF (with optional additive suffixes E, L, and/or Q)
⍝   Allows :DEF name← value  AND   :DEF name value
⍝   E: Evaluate on macro definition;
⍝      L: Literal, Q: Quote after E or L (or both)
⍝   R: Evaluate on each macro replacement...
⍝      L, Q (as above)
  defP←       '^\h*:DEF([LQER]*)\h(?|([^←\n]+)←|([^\h\n←]+)\h)(.*)$'
  undefP←     '^\h*:UNDEF\h+([^\s\n]+)\h*(.*)$'
  parenP←     GenBracePat '()'
  brackP←     GenBracePat '[]'
⍝ :DECLare
⍝ Allows only:   :DECLare name←value
  declareP←   '^\h*:(?:DECLARE|DECL)\h([^←]+)←\h*((?:',parenP,'|',brackP,'|[^[({\n]+)*)$'
⍝ fileIdP matches 
⍝    ::FILE name   OR  ::FILE "name"   OR  ::FILE 'name'
⍝ Final \n: consume the newline to skip __LINE__ increment below...
  fileIdP←'^\h*::FILE\h+(?|''([^''\n]+)''|([^\h\n]+)).*\n'   
 
  Scan4Strings← sqP dqP qtErrP comP nlP miscP ⎕R { 
        sqI dqI qtErrI←   0 1 2
        CASE← ⍵.PatternNum∘∊
        f0← ⍵ Fld 0
      ⍝ SQ strings are by definition aligned LEFT and a bare quote on the first line starts the first quote line.
      ⍝ See AlignLeft for details.
        CASE sqI:  { 
            multi←NL∊f0
            res← multi∘CondParens AddSQs AlignLeft StripTB Strip1LR f0
            SQMULTI_ALLOW ∨ ~multi: res 
            qtE←'∆FIX QUOTE ERROR: Use doublequotes ("...") for multi-line strings:'
            11 ⎕SIGNAL⍨qtE,CR,'[Line] ',res 
        } ⍬
      ⍝ DQ strings are by definition aligned such that a bare first line of the quote is ignored, and
      ⍝ each line is aligned with the first full line which establishes the left margin.
      ⍝ See AlignMarg for details.
        CASE dqI:  (NL∊f0)∘CondParens AddSQs AlignMarg StripTB DQ2SQ Strip1LR f0
        CASE qtErrI: 11 ⎕SIGNAL⍨'∆FIX QUOTE ERROR: No matching quote found:',CR,f0,'...' 
      ⍝ ELSE...
        f0 
  } ⍠OPTS  

  macroPList← sqP comP numP defP undefP declareP wordP nlP fileIdP
  Scan4Macros← macroPList ⎕R {
      sqI comI numI defI undefI declareI wordI nlI fileIdI← ⍳≢macroPList
      CASE← ⍵.PatternNum∘∊
      f0← ⍵ Fld 0 
    ⍝ fileId: Special internal directive that doesn't increase __LINE__
      CASE fileIdI: (VERBOSE/'⍝DBG ',f0) ⊣ MACROSg.Set '__FILE__'  (DoSpaces DoQuotes ⍵ Fld 1)
    ⍝ __LINE__ dictionary value is an integer ≥1.
      _← MACROSg.Set '__LINE__'  ((+/NL=f0)+1 MACROSg.Get '__LINE__') 
      CASE sqI comI numI: f0 
      f1←⍵ Fld 1 
      CASE wordI:  Scan4Words f1 
      CASE nlI:    f0           ⍝ Just needed to count __LINE__ 
      CASE defI:   { 
          f2 f3← ⍵ Fld¨ 2 3
          ¯1=⎕NC f2~'⎕': 11 ⎕SIGNAL⍨ 'XFIX :DEF ERROR: Invalid object name: "',f2,'"',CR,'[Line] ',f0
          hasVal←    ×≢f3~' ' 
          isR←      hasVal ∧ 'R'∊f1                    ⍝ DEFR or DEFER (Execute on each macro replacement)  
          isQnR←    ('Q'∊f1)  ∧~isR                    ⍝ DEFQ and variants (mix of suffixes QLE)  
          isCom←    '⍝'=⊃DLB f3                        ⍝ Is the item a comment? Don't put in parens
          notLit←   ~(isCom ∨ isQnR ∨ hasVal ∧ 'L'∊f1) ⍝ DEFL and variants         
          isEval←   hasVal ∧ ('E'∊f1) ∧ ~isR           ⍝ DEFE (Execute on initial macro evaluation)                                 
          isQR←     ('Q'∊f1)  ∧ isR                    ⍝ DEF[E]RQ
          '⍝ ',f0 ⊣ MACROSg.Set f2 (HandleNL DoPars∘DTB⍣notLit⊣isQnR CondQuotes isEval CondEval Scan4Words f3)(isR×isR+isQR)
      } ⍵
      CASE undefI: { 
          f2← ⍵ Fld 2
          ¯1=⎕NC f1~'⎕': 11 ⎕SIGNAL⍨'XFIX :UNDEF ERROR: Invalid object name: "',f1,'"',CR,'[Line] ',f0
          extra←×≢f2
          extra: 11 ⎕SIGNAL⍨'XFIX :UNDEF ERROR: Trailing text not allowed: "',f2,'"',CR,'[Line] ',f0 
          '⍝ ',f0 ⊣ MACROSg.Del f1 
      } ⍵
      CASE declareI:  { 
        f2←⍵ Fld 2
        nbsp←⎕UCS 160   ⍝ non-breaking space--
        com← '\A' '\n' ⎕R '⍝ ' ('\n⍝',10⍴nbsp)⍠OPTS⊢f0
        scan← f1,'←',0 ⎕SE.Dyalog.Array.Deserialise  Scan4Words f2
        com,NL,scan
      } ⍵ 
  } ⍠OPTS 

  Scan4Words←{
      swReplCount swReplMax← 1 20
      swErrCount  swErrMax←  0  1

      ProcWords← sqP comP numP wordP ⎕R {
        wordI← 3

        ⍵.PatternNum≠wordI:  ⍵.Match    
      ⍝ Convert numberic value to string...
        old≡new← ⍕MACROSg.Get (old←⍵.(Lengths[1]↑Offsets[1]↓Block)): new 
        swReplCount+← 1
        swReplMax≥swReplCount: ProcWords new 
        new {
          swErrCount+← 1
          swErrMax<swErrCount: ⍺ 
          ⎕←'>> XFIX MACRO WARNING: Replacement loop may not terminate: :DEFL ',⍵,' ',⍺
          ⍺ 
        } old 
      } ⍠OPTS

      ProcWords ⍵
  }

⍝ Scan4Specials: 
⍝ processes...
⍝   Fns
⍝    dyadic  quote left   →  
⍝    monadic quote right  `
⍝    monadic sink         ←
⍝  system variable
⍝    sink name            ⎕T 
  tempsN←¯1
  specialPList← sqP comP numP sinkP tempP quotLftP quotRgtP quotRgtErrP 
  Scan4Specials← specialPList ⎕R { 
        sqI comI numI sinkI tempI quotLftI quotRgtI quotRgtErrI ← ⍳≢specialPList
        CASE←⍵.PatternNum∘∊
        CASE sqI comI numI: ⍵ Fld 0
        nm←'⍙T' 
        CASE sinkI:{
            f1← ⍵ Fld 1
            tempsN⊢←⊢ tempsN+1
            f1,nm,(⍕tempsN),'←' 
        } ⍵
        CASE tempI: {
          tempsN<0: 11 ⎕SIGNAL⍨'XFIX ⎕T ERROR: Premature use of ⎕T. No sink value  set.'
          nm, ⍕tempsN
        } ⍬
        CASE quotLftI quotRgtI: (CASE quotLftI){
              bare← 0≠≢f1← ⍵ Fld 1  
              Vec← {  3≠≢⍵: ⍵ ⋄ DoPars ',',⍵ }
              (' '/⍨⍺),(Vec bare CondQuotes f1),⍺⊃  ' ' '(,⍥⊂)' 
        }⍵
        CASE quotRgtErrI: 11 ⎕SIGNAL⍨'XFIX ` ERROR: Invalid use of ` (Quote Right).'
  } ⍠OPTS

⍝ Semicolon disambiguation:   
⍝       (...;...) vs [...;...] vs bare ;, e.g. in tradfn headers.
  Scan4Semicolons←{ 
      LP RP LBk RBk LBc RBc SQ SP SEMI DIAMOND←'()[]{}'' ;⋄'
    ⍝ Stack shared across lines to keep track of dfns braces {}
      lines thisL stack ⎕IO← ⍵ '' ⍬ 0
      ScanLn←{ ⍵≥≢lines: ⍺ ⋄ thisL⊢← ⍵⊃lines ⋄ (⍺,⊂'' ScanCharAt ⍵ 0) ∇ ⍵+1 }
      ScanCharAt←{
          startLix startCix← ⍵ 
          startCix ≥ ≢thisL: ⍺ 
          ch← startCix⊃thisL
          ch∊SQ:⍺{
            ⍝ Search for closing quote. Adjust if not present (though other Scan4Strings will capture)...
              endCix← ch⍳⍨curLC← ⍵↓thisL  
              endCix+←  (≢curLC) > endCix
              (⍺,ch,endCix↑curLC) NextCh startLix(⍵+endCix-1)  
          }startCix + 1 
          ch∊LP LBk LBc: (⍺,ch) NextCh ⍵⊣ stack,←ch
          ch∊RP RBk RBc: (⍺,ch) NextCh ⍵⊣ stack↓⍨←¯1
        ⍝ Directly inside parens, semicolons are treated specially...
        ⍝ Otherwise, let APL handle semicolons.
          ch∊SEMI DIAMOND: ⍺{ LP=⊃⌽stack:(⍺,')(') NextCh ⍵ ⋄ (⍺,ch)NextCh ⍵ }⍵
          ch=SP: (⍺,ch) NextCh ⍵ + 0 (¯1++/∧\SP=startCix↓thisL)
          (⍺,ch) NextCh ⍵
     }
     NextCh← ScanCharAt∘(0 1∘+)
     ⍬ ScanLn 0
  }

⍝ --------------------------------------------

⍝ Executive: Preliminaries
  _←(DEBUG/(⊃⎕LC)+⍳30) ⎕STOP ⊃⎕XSI

  HELP: _←HelpInfo ⍬

⍝ Executive: Initialize Predefined Macros
⍝  __FILE__   Name of input file or '[TERM]'
⍝  __LINE__   Current line number
⍝  Miscellaneous: ⎕AL.LC, etc.
⍝ Note: ⎕AL.LC includes ⎕al.lc (etc.) per definition of "system" macros (with ⎕ prefix).
  ∆UC←⎕A,⎕Á ⋄ ∆LC← ⎕C ∆UC ⋄ ∆MC←∆UC,∆LC
  MACROSg←∆DICT  ('⎕AL.LC'  '⎕AL.UC' '⎕AL.MC') (DoQuotes¨ ∆LC ∆UC ∆MC)
  _←MACROSg.Set '__FILE__'  (DoSpaces DoQuotes'[TERM]')
  _←MACROSg.Set '__FLINE__' (DoSpaces '(__FILE__,''['',(⍕__LINE__),'']'')')

⍝ Executive Main: Scan the input string ⍵ 
  res← Scan4Semicolons Scan4Specials Scan4Macros Scan4Strings Include ⍵
  FIX: 2 HERE.⎕FIX res   ⋄ res 
}
