∆FIX←{   
  ⍺←1
  DEBUG←1
  0/⍨~DEBUG:: ⎕SIGNAL/⎕DMX.(EM EN)
⍝ If ⍵ is a filename (char vector), process the file contents
  1≥|≡⍵: ⍺ ∇ ⊆⊃⎕NGET ⍵ 1
  ⎕IO← 0
  
⍝ ⍵ is (now or initially) a vector of lines (char vectors)

⍝ CONSTANTS
  SQ DQ LP RP←'''"()' 
  CR NL←⎕UCS 13 10 
  DQ2←DQ,DQ
  QSEP←SQ,' ',SQ       ⍝ QSEP: Separates Two Quote Strings 
  OPTS←('UCP' 1)('Mode' 'M')('EOL' 'LF')('IC' 1)

⍝ Utility Fns 
⍝ Fld: Select a numbered field of ⎕R namespace
  Fld← { o b l←⍺.(Offsets Block Lengths) ⋄ 0≠0(≢o)⍸⍵: '' ⋄ ¯1≠oo←⍵⌷o: ll↑oo↓b ⊣ ll←⍵⌷l ⋄ '' }
  AddSQs←     { SQ,SQ,⍨∊(⊂QSEP)@(NL∘=)⊢⍵ }            ⍝ Add single quotes to each quoted string...
  DQ2SQ←      { {⍵/⍨DQ2(~⍷)⍵}(⍵/⍨1+SQ=⍵) }            ⍝ Internal double quotes to single quotes 
  CondParens← { ⍺: Parens ⍵ ⋄ ⍵ }
  CondQuotes← { ⍺: Quotes ⍵ ⋄ ⍵ }
  CondEval←   { 0:: '' ⋄ ⍺: ⍕ ⍎⍵ ⋄ ⍵ }
  Parens←      LP∘,,∘RP
  Quotes←     (SQ∘,,∘SQ)(⊢⊢⍤/⍨1+SQ∘=)
  DTB←        {⍵↓⍨-+/∧\⌽⍵=' '}    
  HandleNL←   { 2≤⍴⍴⍵: ∊∇¨(⎕FMT ⍵),NL  ⋄ '\\⋄' ⎕R '\n' ⊣⍵ }
  Strip1LR←   1↓¯1↓⊢
⍝ Strip trailing blanks from lines of multiline strings...
  StripTB←    { NL(~∊)⍵: ⍵ ⋄ ' *\n'  ⎕R  '\n'  ⍠OPTS ⊢⍵ } 

⍝ Regexp Alignment Fns 
⍝ AlignLeft: No Leading Blanks...
  AlignLeft←  '\n *' ⎕R '\n' ⍠OPTS
⍝ AlignMarg: In a multiline string, 
⍝            align subseq lines with the margin in the first line, ignoring an initial bare newline.
  AlignMarg← {
    isFirst margin skipNL1← 1 0 0
    ⍝ Initial bare newline is ignored...
    ⍝ Set left margin from first "full" line and align following with that.
      '\A(?=\n)' '\n( *)' ⎕R {
          0=⍵.PatternNum: '' ⊣ skipNL1⊢←1                    ⍝ We skip newline at <isFirst>
          nsp← ≢⍵ Fld 1
          isFirst: skipNL1↓NL ⊣ isFirst margin⊢← 0 nsp       ⍝ Set margin 
          NL,' '⍴⍨0⌈margin-⍨nsp                              ⍝ Align with margin         
      }⍠OPTS ⊢ ⍵ 
  }

⍝ Dictionary...
  ∆DICT←{ 
      K V←⍵
      Get←{ 
          k1←1 ⎕C⍣('⎕'=⍬⍴⍵)⊢⍵ 
          p←K⍳⊂k1  ⋄ p=≢K: ⍵ ⋄ p⊃V
      }
      Set←{ k1 v1←⍵
          p←K⍳⊂k1
          p=≢K: v1⊣K,←⊂k1 ⊣ V,←⊂v1
          ⊢(p⊃V)←v1 
      }
      Del←{
          p←K⍳⊂⍵
          p=≢K: ⍵
          q←p≠⍳≢K ⋄ K⊢←q/K ⋄ V⊢←q/V
          ⍵
      }
      ⎕NS  'K' 'V' 'Get' 'Set' 'Del'
  }
  
  sqP←       '(''[^'']*'')+'
  dqP←       '("[^"]*")+' 
  comP←      '⍝[^\n]*$'
  numP←      '¯?[\d\.][\d\.EeJj¯]*'  
  nlP←       '\n'
  miscP←     '[^''"⍝\n]+'
  sinkP←     '((?:^|[[{(⋄:;\n])\h*)←' 
  tempP←     '⎕T\b'
  _w←        '[\w∆⍙]'
  _w0←       '[⎕\w∆⍙](?<![\d¯])'
  _wordP←     _w0,_w,'*(?:\.',_w0,_w,'*)*'
  wordP←      Parens _wordP
  quotLftP←   '(?|(?<='')|',wordP,')\h*→'
  quotRgtP←   '`\h*(?|(?='')|',wordP ,')'
  quotRgtErrP←'`'    
  defP←       '^\h*:DEF([ELQ]*)\h+(\S+)\h?(.*)$'
  undefP←     '^\h*:UNDEF\h+(\S+)\h*(.*)$'

  Scan4Strings← sqP dqP comP nlP miscP ⎕R { 
        sqI dqI←   0 1  
        CASE← ⍵.PatternNum∘∊
        f0← ⍵ Fld 0
        CASE sqI:  (NL∊f0)∘CondParens AddSQs AlignLeft StripTB       Strip1LR f0
        CASE dqI:  (NL∊f0)∘CondParens AddSQs AlignMarg StripTB DQ2SQ Strip1LR f0
      ⍝ ELSE...
        f0 
  } ⍠OPTS  

  Scan4Macros←sqP comP numP defP undefP wordP  ⎕R {
      sqI comI numI defI undefI wordI← 0 1 2 3 4 5
      CASE← ⍵.PatternNum∘∊
      f0← ⍵ Fld 0  
      CASE sqI comI numI: f0 
      f1←⍵ Fld 1 
      CASE wordI:  Scan4Words f1 
      CASE defI:   { f2 f3← ⍵ Fld¨ 2 3
          ¯1=⎕NC f2~'⎕': 11 ⎕SIGNAL⍨ 'XFIX :DEF ERROR: Invalid object name: "',f2,'"',CR,'[Line] ',f0
          hasVal←    ×≢f3~' '
          isQuo←                      'Q'∊f1    ⍝ DEFQ and variants (mix of suffixes QLE)
          isLit←     isQuo ∨ hasVal ∧ 'L'∊f1    ⍝ DEFL and variants        ...
          isEval←            hasVal ∧ 'E'∊f1    ⍝ DEFE and variants        ...
           '⍝ ',f0 ⊣ MACROS.Set f2 (HandleNL Parens∘DTB⍣(~isLit)⊣ isQuo CondQuotes isEval CondEval Scan4Words f3)
      } ⍵
      CASE undefI: { f2← ⍵ Fld 2
          ¯1=⎕NC f1~'⎕': 11 ⎕SIGNAL⍨'XFIX :UNDEF ERROR: Invalid object name: "',f1,'"',CR,'[Line] ',f0
          extra←×≢f2
          extra: 11 ⎕SIGNAL⍨'XFIX :UNDEF ERROR: Trailing text not allowed: "',f2,'"',CR,'[Line] ',f0 
          '⍝ ',f0 ⊣ MACROS.Del f1 
      } ⍵
  } ⍠OPTS 

  Scan4Words←{
      swReplCount swReplMax← 1 20
      swErrCount  swErrMax←  0  1

      ProcWords← sqP comP numP wordP ⎕R {
        wordI← 3
        ⍵.PatternNum≠wordI:  ⍵.Match    
        old≡new← MACROS.Get (old←⍵.(Lengths[1]↑Offsets[1]↓Block)): new 
        swReplCount+← 1
        swReplMax≥swReplCount: ProcWords new 
        new {
          swErrCount+← 1
          swErrMax<swErrCount: ⍺ 
          ⎕←'>> XFIX MACRO WARNING: Replacement loop may not terminate: :DEFL ',⍵,' ',⍺
          ⍺ 
        } old 
      } ⍠OPTS

      ProcWords ⍵
  }

⍝ Scan4Specials: 
⍝ processes...
⍝   Fns
⍝    dyadic  quote left   →  
⍝    monadic quote right  `
⍝    monadic sink         ←
⍝  system variable
⍝    sink name            ⎕T 
  tempsN←¯1
  specialPList← sqP comP numP sinkP tempP quotLftP quotRgtP quotRgtErrP 
  Scan4Specials← specialPList ⎕R { 
        sqI comI numI sinkI tempI quotLftI quotRgtI quotRgtErrI ← ⍳≢specialPList
        CASE←⍵.PatternNum∘∊
        CASE sqI comI numI: ⍵ Fld 0
        nm←'⍙T' 
        CASE sinkI:{
            f1← ⍵ Fld 1
            tempsN⊢←⊢ tempsN+1
            f1,nm,(⍕tempsN),'←' 
        } ⍵
        CASE tempI: {
          tempsN<0: 11 ⎕SIGNAL⍨'XFIX ⎕T ERROR: Premature use of ⎕T. No sink value  set.'
          nm, ⍕tempsN
        } ⍬
        CASE quotLftI quotRgtI: (CASE quotLftI){
              bare← 0≠≢f1← ⍵ Fld 1  
              Vec← {  3≠≢⍵: ⍵ ⋄ Parens ',',⍵ }
              (' '/⍨⍺),(Vec bare CondQuotes f1),⍺⊃  ' ' '(,⍥⊂)' 
        }⍵
        CASE quotRgtErrI: 11 ⎕SIGNAL⍨'XFIX ` ERROR: Invalid use of ` (Quote Right).'
  } ⍠OPTS

⍝ Semicolon disambiguation
  Scan4Semicolons←{
     LP RP LBk RBk LBc RBc QT Semi←'()[]{}'';'
     stk←⍬                           ⍝ Stack shared across lines to keep track of dfns braces {}
     str←''
     ScanAllLines←{
        str⊢← ⊃⍵   
        0=≢⍵: ⍺ 
        (⍺,⊂⍬ ∆ ⊃⍵) ∇ 1↓⍵ 
     }
     ∆←{   
         0=≢⍵:⍺
         f←⊃⍵
         f=QT:⍺{
             p←⍵⍳QT
             p=≢⍵:11 ⎕SIGNAL⍨'Unmatched quotes in "',str,'"' 
             (⍺,f,⍵↑⍨p+1) ∆  ⍵↓⍨p+1
         }1↓⍵
         f∊LP LBk LBc: (⍺,f) ∆  1↓⍵⊣ stk,←f
         f∊RP RBk RBc: (⍺,f) ∆ 1↓⍵⊣ stk↓⍨←¯1
         f=Semi:⍺{
             LP=⊃⌽stk:(⍺,')(') ∆ ⍵   ⍝ Semicolons within parens treated specially...
             (⍺,f)∆ ⍵                ⍝ Let APL handle semicolons otherwise
         }1↓⍵
         (⍺,f)∆ 1↓⍵
     }
     ⍬ ScanAllLines ⍵ 
 }

  ∆UC ∆LC← (⎕A,⎕Á)(⎕C⎕A,⎕Á)
  ∆MC←∆UC,∆LC
  MACROS←∆DICT  ('⎕LC'  '⎕UC' '⎕MC') (Quotes¨ ∆LC ∆UC ∆MC)
  res← Scan4Semicolons Scan4Specials Scan4Macros Scan4Strings ⍵
  ×⍺: 2 ⎕FIX res ⋄ res 
}
